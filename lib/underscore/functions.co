_ = require 'underscore'


slice       = [].slice
hasOwn      = {}.hasOwnProperty
objToString = {}.toString

toArray = _.toArray



decorate = (fn) ->
    if not fn.__decorated__
        for name of _pet.FUNCTION_METHODS
            m = _[name]
            fn[name] = m.__methodized__ or methodize m
        fn.__decorated__ = true
    return fn

methodize = (fn) ->
    m = fn.__methodized__
    return m if m
    
    g = fn.__genericized__
    return g.__wraps__ if g and g.__wraps__
    
    m = fn.__methodized__ = (args...) ->
        args.unshift this
        return fn.apply this, args
    
    m.__wraps__ = fn
    return decorate m



_pet = module.exports = \
    function pet (o, start=0, end=undefined) ->
        if _.isArguments o
            o = _.toArray o, start, end
        
        return decorate o if typeof o is 'function'
        return _ o

# function methods to be attached on call to _(fn)
_pet.FUNCTION_METHODS = [
    'bind', 'bindAll', 'memoize', 
    'delay', 'defer', 'throttle', 'debounce', 'once', 'after', 
    'wrap', 'compose',
    'unwrap', 'partial', 'curry', 'flip', 'methodize', 'aritize', 'limit'
]


class2name = "Boolean Number String Function Array Date RegExp Object"
        .split(" ")
        .reduce ((class2name, name) ->
            class2name[ "[object "+name+"]" ] = name
            return class2name), {}


## Objects
_.mixin
    
    has: (o, v) ->
        vals = if _.isArray(o) then o else _.values(o)
        return vals.indexOf(v) is not -1
    
    remove: (o, vs...) ->
        if _.isArray(o)
            _.each vs, (v) ->
                idx = o.indexOf v
                if idx is not -1
                    o.splice idx, 1
        else
            _.each o, (v, k) ->
                if vs.indexOf(v) != -1
                    delete o[k]
        return o
    
    set: (o, key, value, def) ->
        if o and key? and (value? or def?)
            o[key] = value ? def
        return o
    
    attr: (o, key, value, def) ->
        return o if not o or key is undefined
        
        if _.isPlainObject key
            return _.extend o, key
        
        if (value ? def) is not undefined
            return _.set o, key, value, def
        
        return o[key]
    
    

## Types
_.mixin
    
    basicTypeName: (o) ->
        return if o is null then "null" else (class2name[objToString.call(o)] || "Object")
    
    isWindow: (o) ->
        return o and typeof o is "object" and "setInterval" of o
    
    isPlainObject: (o) ->
        # Must be an Object.
        # Because of IE, we also have to check the presence of the constructor property.
        # Make sure that DOM nodes and window objects don't pass through, as well
        if not o or basicTypeName(o) is not "Object" or o.nodeType or _.isWindow(o)
            return false
        
        # Not own constructor property? must be Object
        C = o.constructor
        if C and not hasOwn.call(o, "constructor") and not hasOwn.call(C.prototype, "isPrototypeOf")
            return false
        
        # Own properties are enumerated firstly, so to speed up,
        # if last one is own, then all properties are own.
        for key in o
            ; # semicolon **on new line** is required by coffeescript to denote empty statement.
        
        return key is void or hasOwn.call(o, key)
    

## Arrays
_.mixin
    
    toArray: (iterable, start=0, end=undefined) ->
        _.slice toArray(iterable), start, end
    
    flatten: (A) ->
        _.reduce do
            slice.call(arguments)
            (flat, v) ->
                flat.concat( if _.isArray v then _.reduce(v, arguments.callee, []) else v )
            []
    


## Functions
_ofArity = _.memoize do
    (n, limit) ->
        args       = ( '$'+i for i from 0 til n ).join(',')
        name       = ( if limit then 'limited' else 'artized' )
        apply_with = ( if limit then "[].slice.call(arguments, 0, #{n})" else 'arguments' )
        return eval "
            (function #{name}(fn){
                var _fn = function(#{args}){ return fn.apply(this, #{apply_with}); };
                _fn.__wraps__ = fn;
                return _(_fn);
            })"

_.mixin do
    methodize
    
    unwrap: (fn) ->
        (fn and _.isFunction(fn) and _.unwrap(fn.__wraps__)) or fn
    
    
    partial: (fn, ...args) ->
        partially = ->
            fn.apply this, args.concat slice.call(arguments)
        _ partially import { __wraps__:fn }
    
    
    genericize: (fn) ->
        return that if fn.__genericized__
        return that if fn.__methodized__?.__wraps__
        
        fn.__genericized__ = (...args) ->
            fn.apply args.shift(), args
        
        _ fn.__genericized__ import { __wraps__:fn }
    
    
    curry: (fn, ...args) ->
        return fn unless _.isFunction fn
        return fn.apply this, args if fn.__curried__
        
        L = fn.length or _.unwrap(fn).length
        return fn.apply this, args if args.length >= L
        
        curried = ->
            _args = args.concat slice.call(arguments)
            return fn.apply this, _args if _args.length >= L
            _args.unshift fn
            _.curry.apply this, _args
        
        _ curried import
            __wraps__   : fn
            __curried__ : args
    
    
    flip: (fn) ->
        return that if fn.__flipped__
        
        fn.__flipped__ = ->
            [arguments[0], arguments[1]] = [arguments[1], arguments[0]]
            fn ...
        
        _ fn.__flipped__ import { __wraps__:fn }
    
    
    aritize: (fn, n) ->
        return fn if fn.length is n
        fn.__aritized__ or= {}
        fn.__aritized__[n] or= _ofArity(n, false)(fn)
    
    
    limit: (fn, n) ->
        fn.__limited__ or= {}
        fn.__limited__[n] or= _ofArity(n, true)(fn)
    
    
    



_.extend _pet, _
