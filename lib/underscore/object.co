_ = require 'underscore'

OBJ_PROTO = Object.prototype
getProto = Object.getPrototypeOf

_obj = do
    
    isPlainObject : (o) ->
        !! o and _.isObject(o) and OBJ_PROTO is getProto(o)
    
    /**
     * Converts the collection to a list of its items:
     * - Objects become a list of `[key, value]` pairs.
     * - Strings become a list of characters.
     * - Arguments objects become an array.
     * - Arrays are copied.
     */
    items: (obj) ->
        if _.isObject(obj) and not _.isArguments(obj)
            _.map obj, (v, k) -> [k, v]
        else
            [].slice.call obj
    
    /**
     * In-place removal of a value from an Array or Object.
     */
    remove: (obj, v) ->
        values = [].slice.call arguments, 1
        if _.isArray obj
            for v of values
                idx = obj.indexOf v
                obj.splice idx, 1 if idx is not -1
        else
            for k, v in obj
                delete obj[k] if -1 is not values.indexOf v
        obj
    
    
    
    toKV: (o, item_delim='&', kv_delim='=') ->
        _.reduce do
            o
            (acc, v, k) ->
                acc.push encodeURIComponent(k)+kv_delim+encodeURIComponent(v) if k
                acc
            []
        .join item_delim
    
    fromKV: (qs, item_delim='&', kv_delim='=') ->
        _.reduce do
            qs.split item_delim
            (acc, pair) ->
                idx = pair.indexOf kv_delim
                if idx is not -1
                    [k, v] = [pair.slice(0, idx), pair.slice(idx+1)]
                else
                    [k, v] = [pair, '']
                acc[ decodeURIComponent k ] = decodeURIComponent v if k
                acc
            {}
    
    /**
     * Copies and flattens any sub-objects into namespaced keys on the parent object, such 
     * that `{ "foo":{ "bar":1 } }` becomes `{ "foo.bar":1 }`.
     */
    collapseObject: (obj, parent={}, prefix='') ->
        prefix += '.' if prefix
        _.each obj, (v, k) ->
            if _.isPlainObject v
                _.collapseObject v, parent, prefix+k
            else
                parent[prefix+k] = v
        parent
    
    /**
     * Inverse of `.collapseObject()` -- copies and expands any dot-namespaced keys in the object, such
     * that `{ "foo.bar":1 }` becomes `{ "foo":{ "bar":1 }}`.
     */
    uncollapseObject: (obj) ->
        _.reduce do
            obj
            (acc, v, k) ->
                _.setNested acc, k, v, true
                acc
            {}
    
    /**
     * Searches a heirarchical object for a given subkey specified in dotted-property syntax.
     * @param {Object} base The object to serve as the root of the property-chain.
     * @param {Array|String} chain The property-chain to lookup.
     * @param {Boolean} [ensure=false] If true, intermediate keys that are `null` or
     *  `undefined` will be filled in with a new empty object `{}`, ensuring the get will
     *   return valid metadata.
     * @retruns {undefined|Object} If found, the object is of the form 
     *  `{ key: Qualified key name, obj: Parent object of key, val: Value at obj[key] }`. 
     *  Otherwise `undefined`.
     */
    getNestedMeta : (obj, chain, ensure=false) ->
        chain = chain.split('.') if typeof chain is 'string'
        _.reduce do
            chain
            (current, key, idx, chain) ->
                return undefined unless current?
                
                if idx is chain.length-1
                    return
                        obj : current
                        key : key
                        val : current[key]
                
                val = current[key]
                if val?
                    val
                else if ensure 
                    current[key] = {}
                else
                    undefined
            obj
    
    /**
     * Searches a heirarchical object for a given subkey specified in dotted-property syntax.
     * @param {Object} obj The object to serve as the root of the property-chain.
     * @param {Array|String} chain The property-chain to lookup.
     * @param {Any} def Value to return if lookup fails.
     * @retruns {null|Object} If found, returns the value, and otherwise `default`.
     */
    getNested : (obj, chain, def=null) ->
        meta = _obj.getNestedMeta obj, chain
        if meta
            meta.val
        else
            def
    
    /**
     * Searches a heirarchical object for a given subkey specified in
     * dotted-property syntax, setting it with the provided value if found.
     * @param {Object} obj The object to serve as the root of the property-chain.
     * @param {Array|String} chain The property-chain to lookup.
     * @param {Any} value The value to set.
     * @param {Boolean} [ensure=false] If true, intermediate keys that are `null` or
     *  `undefined` will be filled in with a new empty object `{}`, ensuring the set
     *  will succeed.
     * @retruns {undefined|Any} If found, returns the old value, and otherwise `undefined`.
     */
    setNested : (obj, chain, value, ensure=false) ->
        meta = _obj.getNestedMeta obj, chain, ensure
        if meta
            meta.obj[meta.key] = value
            meta.val
        else
            undefined
    
    /**
     * Searches a heirarchical object for a given subkey specified in
     * dotted-property syntax, removing it if found.
     * @param {Object} obj The object to serve as the root of the property-chain.
     * @param {Array|String} chain The property-chain to lookup.
     * @param {Boolean} [ensure=false] If true, intermediate keys that are `null` or
     *  `undefined` will be filled in with a new empty object `{}`, ensuring the set
     *  will succeed.
     * @retruns {undefined|Any} If found, returns the old value, and otherwise `undefined`.
     */
    unsetNested : (obj, chain, ensure=false) ->
        meta = _obj.getNestedMeta obj, chain, ensure
        if meta
            delete meta.obj[meta.key]
            meta.val
        else
            undefined
    

exports import _obj
