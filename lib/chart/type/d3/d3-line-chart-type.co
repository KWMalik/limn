d3 = require 'd3'
ColorBrewer = require 'colorbrewer'

{ _, op,
} = require 'kraken/util'
{ ChartType,
} = require 'kraken/chart/chart-type'

root = do -> this


class exports.LineChartType extends ChartType
    __bind__ : <[ determineSize ]>
    SPEC_URL : '/schema/d3/d3-line.json'
    
    # NOTE: ChartType.register() must come AFTER `typeName` declaration.
    typeName : 'd3-line'
    ChartType.register this
    
    
    /**
     * Hash of role-names to the selector which, when applied to the view,
     * returns the correct element.
     * @type Object
     */
    roles :
        viewport : '.viewport'
        legend   : '.graph-legend'
    
    
    -> super ...
    
    
    getData: ->
        @model.dataset.getColumns()
    
    
    transform: ->
        dataset = @model.dataset
        options = @model.getOptions() import @determineSize()
        options import do
            colors             : dataset.getColors()
            labels             : dataset.getLabels()
        options
    
    renderChartType: (metric, svgEl ,xScale, yScale) ->        
        
        X = (d, i) -> xScale d[0]
        Y = (d, i) -> yScale d[1]
        line = d3.svg.line().x(X).y(Y)

        ### Render the line path
        metricLine = root.metricLine = svgEl.append "g"
            .attr "class", "g metric line "+metric.get 'label'
                
        data = d3.zip metric.getDateColumn(),metric.getData()                

        metricLine.selectAll "path.line"
            .data d3.zip data.slice(0,-1), data.slice(1)
            .enter().append "path"
                .attr "d", line
                .attr "class", (d, i) -> "metric line segment #i"
                .style "stroke", metric.get 'color'

        
        ### Mouse Lens
        lens = root.lens = svgEl.selectAll "g.lens"
            .data [[]]
        gLens = lens.enter().append "g"
            .attr "class", "lens"
            .style "z-index", 1e9
        gInner = gLens.append "g"
            .attr "transform", "translate(1.5em,0)"
        gInner.append "circle"
            .attr "r", "1.5em"
            # .style "opacity", "0.4"
            # .style "fill", "white"
            .style "fill", "rgba(255, 255, 255, 0.4)"
            .style "stroke", "white"
            .style "stroke-width", "3px"
        gInner.append "text"
            .attr "y", "0.5em"
            .attr "text-anchor", "middle"
            .style "fill", "black"
            .style "font", "12px Helvetica"
            .style "font-weight", "bold"

        # event listeners
        chT = this
        metricLine.selectAll ".line.segment"
            .on "mouseover", (d, i) ->
                
                {r,g,b} = color = d3.rgb metric.get 'color'                
                lineX = (X(d[0])+X(d[1]))/2
                lineY = (Y(d[0])+Y(d[1]))/2
                                

                lens = svgEl.select "g.lens"                
                    .attr "transform", "translate(#lineX, #lineY)"
                lens.select "circle" .style "fill", "rgba(#r, #g, #b, 0.4)"
                lens.select "text" .text -> chT.numberFormatter(d[0][1]).toString()


        svgEl        

    
    renderChart: (data, viewport, options, lastChart) ->
        ### Starting with http://bost.ocks.org/mike/chart/
        
        margin = {top: 20, right: 20, bottom: 20, left: 20}
        width  = 760
        height = 320
        xScale = d3.time.scale()
        yScale = d3.scale.linear()
        
        dates  = data[0]
        cols   = data.slice(1)
        
        # Calculate extents using all the data points (but not dates)
        # allValues = d3.merge @model.dataset.getDataColumns()
        allValues = d3.merge cols
        
        
        # Update the x-scale with the extents of the dates.
        xScale
            .domain d3.extent dates
            .range [ 0, width - margin.left - margin.right ]
        
        # Update the y-scale with the extents of the data.
        yScale
            .domain d3.extent allValues
            .range [ height - margin.top - margin.bottom, 0 ]
        
        # Select the svg element, if it exists.
        svg = d3.select viewport.0 .selectAll "svg"
            .data [cols]
        
        # ...Otherwise, create the skeletal chart.
        enterFrame = svg.enter()
            .append "svg" .append "g"
                .attr "class", "frame"
        enterFrame.append "g"
            .attr "class", "x axis time"
        
        # Update chart dimensions.
        svg .attr "width", width
            .attr "height", height
        frame = svg.select "g.frame"
            .attr "transform", "translate(#{margin.left},#{margin.top})"
        
        # Update the x-axis.
        xAxis = d3.svg.axis().scale(xScale).orient("bottom").tickSize(6, 0)
        frame.select ".x.axis.time"
            .attr "transform", "translate(0,#{yScale.range()[0]})"
            .call xAxis
        
        
        ### Render the line paths
        lines = root.lines = frame.selectAll "path.line"
            .data cols.map -> d3.zip dates, it
        lines.enter().append "path"
            .attr "class", "metric line"
        lines.exit().remove()
        
        X = (d, i) -> xScale d[0]
        Y = (d, i) -> yScale d[1]
        line = d3.svg.line().x(X).y(Y)
        lines.attr "d", line
            .attr "class", (col, i) -> "metric line metric#i"
            .style "stroke", (col, i) -> options.colors[i]
            .each (col, i) ->
                {width} = bbox = @getBBox()
                # Add line-to-data position conversions
                @indexAtX = d3.scale.quantize()
                    .domain [0, width]
                    .range d3.range col.length
                @indexToPoint = (idx) ->
                    @pathSegList.getItem idx
        
        ### Render Points
        points = frame.selectAll "g.points"
            .data cols
        points.enter().append "g"
            .attr "class", (col, i)     ->  "points points#i"
            .property "line", (col, i)  -> $(this).parent().find('path.metric.line')[i]
        points.exit().remove()
        
        points.selectAll ".point"
            .data op.first
            .enter().append "circle"
                .attr "class", "point"
                .attr "r", "2px"
                .property "line", -> $ this .parentsUntil('svg', 'g')[0].line
                .style "fill", -> $ this.line .css 'stroke'
                .attr "transform", (d, i) ->
                    {x,y} = @line.indexToPoint i
                    "translate(#x, #y)"
        
        
        ### Mouse Lens
        lens = root.lens = frame.selectAll "g.lens"
            .data [[]]
        gLens = lens.enter().append "g"
            .attr "class", "lens"
            .style "z-index", 1e9
        gInner = gLens.append "g"
            .attr "transform", "translate(1.5em,0)"
        gInner.append "circle"
            .attr "r", "1.5em"
            # .style "opacity", "0.4"
            # .style "fill", "white"
            .style "fill", "rgba(255, 255, 255, 0.4)"
            .style "stroke", "white"
            .style "stroke-width", "3px"
        gInner.append "text"
            .attr "y", "0.5em"
            .attr "text-anchor", "middle"
            .style "fill", "white"
            .style "font", "12px Helvetica"
            .style "font-weight", "bold"
        
        lines.on "mouseover", (col, i) ->
            line = root.line = this # DOM element of event
            {r,g,b} = color = d3.rgb options.colors[i]
            
            # quantize mouse x-location to get for closest data-point (index into data array)
            [x,y] = root.pos = d3.mouse line
            idx = root.idx = line.indexAtX x
            {x:lineX, y:lineY} = root.pt = line.indexToPoint idx
            
            lens = frame.select "g.lens"                
                .attr "transform", "translate(#lineX, #lineY)"
            lens.select "circle" .style "fill", "rgba(#r, #g, #b, 0.4)"
            lens.select "text" .text -> col[idx][1]
        
        
        points.on "mouseover", (d, i) ->
            line = root.line = this.line # this is the DOM element of point
            {r,g,b} = color = d3.rgb options.colors[i]
                        
            # quantize mouse x-location to get for closest data-point (index into data array)
            [x,y] = root.pos = d3.mouse line
            idx = root.idx = line.indexAtX x
            {x:lineX, y:lineY} = root.pt = line.indexToPoint idx
            
            lens = frame.select "g.lens"                
                .attr "transform", "translate(#lineX, #lineY)"
            lens.select "circle" .style "fill", "rgba(#r, #g, #b, 0.4)"
            lens.select "text" .text -> d[idx]

        
        svg
    
    
    
