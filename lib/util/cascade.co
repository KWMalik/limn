_ = require 'kraken/underscore'


/**
 * @class A mapping of key-value pairs supporting lookup fallback across multiple objects.
 */
class Cascade
    
    /**
     * Map holding the object's KV-pairs. It is also the first element of the
     * cascade lookup.
     * @type Object
     * @private
     */
    _data : null
    
    /**
     * List of objects for lookups.
     * @type Array
     * @private
     */
    _lookups : null
    
    
    
    /**
     * @constructor
     */
    (data={}, lookups=[]) ->
        @_data    = data
        @_lookups = [@_data].concat lookups
    
    
    /**
     * @returns {Cascade} A copy of the data and lookup chain.
     */
    clone: ->
        new Cascade {} import @_data, @_lookups.slice()
    
    
    
    ### Data & Lookups ###
    
    setData: (data) ->
        @_data = @_lookups[0] = data
        this
    
    /**
     * Adds a new lookup dictionary to the chain.
     * @returns {this}
     */
    addLookup: (dict) ->
        return this unless dict?
        throw new Error "Lookup dictionary must be an object! dict=#dict" unless dict
        @_lookups.push dict
        this
    
    /**
     * Removes a lookup dictionary from the chain.
     * @returns {this}
     */
    removeLookup: (dict) ->
        _.remove @_lookups, dict if dict
        this
    
    /**
     * @returns {Boolean} Whether the value at `key` belongs to this object or exists in the cascade.
     */
    isOwnValue: (key) ->
        @_data[key] is not void
    
    /**
     * @returns {Number} Number of lookup dictionaries.
     */
    size: ->
        @_lookups.length
    
    
    
    ### Value Accessors ###
    
    /**
     * @returns {Boolean} Whether there is a value at the given key.
     */
    has : (key) ->
        (@get key, void) is not void
    
    /**
     * @returns {*} First value for the given key found in the lookup chain,
     * and the default otherwise.
     */
    get : (key, def) ->
        for data of @_lookups
            if typeof data.get is 'function'
                val = data.get key, void
            else
                val = _.getNested data, key, void
            return val if val is not void
        def
    
    /**
     * Sets a key to a value, accepting nested keys and creating intermediary objects as necessary.
     * @public
     * @name set
     * @param {String} key Key to set.
     * @param {*} val Non-`undefined` value to set.
     * @returns {this}
     */
    /**
     * @public
     * @name set
     * @param {Object} values Map of KV pairs to set. No value may be `undefined`.
     * @returns {this}
     */
    set : (values) ->
        # Handle @set(k, val)
        if arguments.length > 1 and typeof values is 'string'
            [key, val] = arguments
            throw new Error("Value and key cannot be undefined!") if not key or val is void
            values = { "#key": val }
        
        # Trailing `true` in call to `set()` and `setNested()` is to ensure the
        # creation of missing intermediate objects.
        if typeof @_data.set is 'function'
            for key, val in values then @_data.set key, val, true
        else
            for key, val in values then _.setNested @_data, key, val, true
        
        this
    
    
    /**
     * Delete the given key from this object's concrete data. If missing,
     * does not cascade.
     * @returns {undefined|*} If found, returns the old value, and otherwise `undefined`.
     */
    unset: (key) ->
        _.unsetNested @_data, key
    
    
    
    ### Collection Methods ###
    
    extend : (...args) ->
        for o of args
            for k, v in o then @set k, v
        this
    
    toObject: ->
        _.extend {}, ...@_lookups
    
    keys: ->
        _.flatten _.map @_lookups, -> _.keys it
    
    values: ->
        _.flatten _.map @_lookups, -> _.values it
    
    reduce : (fn, acc, context=this) ->
        _.reduce @_lookups, fn, acc, context
    
    map : (fn, context=this) ->
        _.map @_lookups, fn, context
    
    filter: (fn, context=this) ->
        _.filter @_lookups, fn, context
    
    each : (fn, context=this) ->
        _.each @_lookups, fn, context
        this
    
    invoke : (name, ...args) ->
        _.invoke @_lookups, name, ...args
    
    pluck : (attr) ->
        _.pluck @_lookups, attr
    
    find: (fn, context=this) ->
        _.find @_lookups, fn, context
    
    
    
    toString: ->
        Cls = this.constructor
        "#{Cls.displayName or Cls.name}()"



module.exports = exports = Cascade
