_ = require 'kraken/util/underscore'

hasOwn = ({}).hasOwnProperty

# Sentinel for missing values.
MISSING = void


/**
 * @class A mapping of key-value pairs supporting lookup fallback across multiple objects.
 */
class Cascade
    
    /**
     * Map holding the object's KV-pairs. It is also the first element of the
     * cascade lookup.
     * @type Object
     * @private
     */
    _data : null
    
    /**
     * List of objects for lookups.
     * @type Array
     * @private
     */
    _lookups : null
    
    
    
    /**
     * @constructor
     */
    (data={}, lookups=[]) ->
        @_data    = data
        @_lookups = [@_data].concat lookups
    
    
    /**
     * @returns {Cascade} A copy of the data and lookup chain.
     */
    clone: ->
        new Cascade {} import @_data, @_lookups.slice()
    
    
    
    ### Data & Lookups ###
    
    getData: ->
        @_data
    
    setData: (data) ->
        @_data = @_lookups[0] = data
        this
    
    /**
     * Adds a new lookup dictionary to the chain.
     * @returns {this}
     */
    addLookup: (dict) ->
        return this unless dict?
        throw new Error "Lookup dictionary must be an object! dict=#dict" unless _.isObject dict
        @_lookups.push dict
        this
    
    /**
     * Removes a lookup dictionary from the chain.
     * @returns {this}
     */
    removeLookup: (dict) ->
        _.remove @_lookups, dict if dict
        this
    
    /**
     * @returns {Boolean} Whether `key` belongs to this object (not inherited
     *  from the cascade).
     */
    hasOwnProperty: (key) ->
        meta = _.getNestedMeta(@_data, key)
        meta?.obj and hasOwn.call meta.obj, key
    
    /**
     * @returns {Boolean} Whether `key` belongs to this object (not inherited
     *  from the cascade) and is defined.
     */
    isOwnValue: (key) ->
        @hasOwnProperty(key) and _.getNested(@_data, key, MISSING) is not MISSING
    
    /**
     * @returns {Boolean} Whether the value at `key` is different from that
     *  inherited by from the cascade.
     */
    isChangedValue: (key, strict=false) ->
        val = @get key
        cVal = @_getInCascade key, MISSING, 1
        if strict
            val is not cVal
        else
            not _.isEqual val, cVal
    
    /**
     * @returns {Boolean} Whether the value at `key` is the same as that
     *  inherited by from the cascade.
     */
    isInheritedValue: (key, strict=false) ->
        not @isChangedValue key, strict
    
    /**
     * @returns {Number} Number of lookup dictionaries.
     */
    size: ->
        @_lookups.length
    
    
    
    ### Value Accessors ###
    
    /**
     * @private
     * @param {String} key Key to look up.
     * @param {*} [def=undefined] Value to return if lookup fails.
     * @param {Number} [idx=0] Index into lookup list to begin search.
     * @returns {*} First value for `key` found in the lookup chain starting at `idx`,
     *  and `def` otherwise.
     */
    _getInCascade : (key, def, idx=0) ->
        for data of @_lookups.slice(idx)
            val = _.getNested data, key, MISSING
            return val unless val is MISSING
        def
    
    /**
     * @returns {Boolean} Whether there is a value at the given key.
     */
    has : (key) ->
        @get(key, MISSING) is not MISSING
    
    /**
     * @param {String} key Key to look up.
     * @param {*} [def=undefined] Value to return if lookup fails.
     * @returns {*} First value for `key` found in the lookup chain,
     *  and `def` otherwise.
     */
    get : (key, def) ->
        @_getInCascade key, def
    
    /**
     * Sets a key to a value, accepting nested keys and creating intermediary objects as necessary.
     * @public
     * @name set
     * @param {String} key Key to set.
     * @param {*} value Non-`undefined` value to set.
     * @returns {this}
     */
    /**
     * @public
     * @name set
     * @param {Object} values Map of pairs to set. No value may be `undefined`.
     * @returns {this}
     */
    set : (values) ->
        # Handle @set(k, val)
        if arguments.length > 1 and typeof values is 'string'
            [key, val] = arguments
            throw new Error("Value and key cannot be undefined!") if not key or val is void
            values = { "#key": val }
        
        # Set and ensure the creation of missing intermediate objects.
        for key, val in values
            _.setNested @_data, key, val, {+ensure}
        
        this
    
    
    /**
     * Delete the given key from this object's concrete data. If missing,
     * does not cascade.
     * @returns {undefined|*} If found, returns the old value, and otherwise `undefined`.
     */
    unset: (key) ->
        _.unsetNested @_data, key
    
    
    
    ### Collection Methods ###
    
    extend : ->
        for o of arguments then @set o
        this
    
    toJSON: ->
        _.extend {}, ...@_lookups.slice().reverse()
    
    # XXX: should unique? but then won't map 1:1 to @values()...
    keys: ->
        _.flatten _.map @_lookups, -> _.keys it
    
    values: ->
        _.flatten _.map @_lookups, -> _.values it
    
    reduce : (fn, acc, context=this) ->
        _.reduce @_lookups, fn, acc, context
    
    map : (fn, context=this) ->
        _.map @_lookups, fn, context
    
    filter: (fn, context=this) ->
        _.filter @_lookups, fn, context
    
    each : (fn, context=this) ->
        _.each @_lookups, fn, context
        this
    
    invoke : (name, ...args) ->
        _.invoke @_lookups, name, ...args
    
    pluck : (attr) ->
        _.pluck @_lookups, attr
    
    find: (fn, context=this) ->
        _.find @_lookups, fn, context
    
    
    
    toString: ->
        Cls = this.constructor
        "#{Cls.displayName or Cls.name}()"


ALIASES =
    toJSON : 'toObject'
    each   : 'forEach'

for src, dest in ALIASES
    Cascade::[dest] = Cascade::[src]

module.exports = exports = Cascade
