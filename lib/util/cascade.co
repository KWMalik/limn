_ = require 'kraken/underscore'


/**
 * @class A mapping of key-value pairs supporting lookup fallback across multiple objects.
 */
class Cascade
    
    /**
     * Map holding the object's KV-pairs. It is also the first element of the
     * cascade lookup.
     * @type Object
     * @private
     */
    _data : null
    
    /**
     * List of objects for lookups.
     * @type Array
     * @private
     */
    _lookups : null
    
    
    
    /**
     * @constructor
     */
    (data={}, lookups=[]) ->
        @_data = {} import data
        @_lookups = [@_data].concat lookups.slice()
    
    
    /**
     * @returns {Cascade} A copy of the lookup chain.
     */
    clone: ->
        new Cascade @_data, @_lookups
    
    
    
    ### Lookups ###
    
    /**
     * Adds a new lookup dictionary to the chain.
     * @returns {this}
     */
    addLookup: (dict) ->
        @_lookups.push dict
        this
    
    /**
     * Removes a lookup dictionary from the chain.
     * @returns {this}
     */
    removeLookup: (dict) ->
        _.remove @_lookups, dict
        this
    
    
    
    
    ### Value Accessors ###
    
    /**
     * @returns {Boolean} Whether there is a value at the given key.
     */
    has : (key) ->
        (@get key, undefined) is not undefined
    
    
    /**
     * @returns {*} First value for the given key found in the lookup chain,
     * and the default otherwise.
     */
    get : (key, def) ->
        for data of @_lookups
            val = _.getNested data, key, undefined
            return val if val is not undefined
        def
    
    /**
     * @param {String} key Key to set.
     * @param {*} val Non-`undefined` value to set.
     * @returns {this}
     */
    set : (key, val) ->
        throw new Error("Value and key cannot be undefined!") unless key and val is not undefined
        _.setNested @_data, key, val
        this
    
    
    /**
     * Delete the given key from this object's concrete data. If missing,
     * does not cascade.
     * @returns {undefined|*} If found, returns the old value, and otherwise `undefined`.
     */
    del: (key) ->
        _.unsetNested @_data, key, false
    
    
    
    ### Collection Methods ###
    
    extend : (...args) ->
        for o of args
            for k,v in o then @set k, v
        this
    
    toObject: ->
        _.extend {}, ...@_lookups
    
    keys: ->
        _.flatten _.map @_lookups, -> _.keys it
    
    values: ->
        _.flatten _.map @_lookups, -> _.values it
    
    reduce : (fn, acc, context=this) ->
        _.reduce @_lookups, fn, acc, context
    
    map : (fn, context=this) ->
        _.map @_lookups, fn, context
    
    filter: (fn, context=this) ->
        _.filter @_lookups, fn, context
    
    each : (fn, context=this) ->
        _.each @_lookups, fn, context
        this
    
    invoke : (name, ...args) ->
        _.invoke @_lookups, name, ...args
    
    pluck : (attr) ->
        _.pluck @_lookups, attr
    
    find: (fn, context=this) ->
        _.find @_lookups, fn, context
    
    
    
    toString: ->
        Cls = this.constructor
        "#{Cls.displayName or Cls.name}()"



module.exports = exports = Cascade
