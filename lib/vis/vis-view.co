root = do -> this

_ = require 'kraken/underscore'
{ BaseView,
} = require 'kraken/base'
{ Field, FieldList, FieldView, Scaffold
} = require 'kraken/scaffold'
{   GraphOptionsScaffold, GraphOption, GraphOptionList, DEBOUNCE_RENDER,
} = require 'kraken/graph'
{ VisModel,
} = require 'kraken/vis/vis-model'





/**
 * View for a graph visualization encapsulating the UI for:
 * - Graph metadata, such as name, description, slug
 */
VisView = exports.VisView = BaseView.extend do # {{{
    FILTER_CHART_OPTIONS : <[ 
        file labels visibility colors dateWindow ticker timingName xValueParser
        axisLabelFormatter xAxisLabelFormatter yAxisLabelFormatter
        valueFormatter xValueFormatter yValueFormatter
    ]>
    __bind__  : <[ 
        render renderAll resizeViewport
        formatter axisFormatter
        onReady onModelChange onScaffoldChange onFirstClickRenderOptionsTab
    ]>
    __debounce__: <[ render renderAll ]>
    ctorName  : 'VisView'
    tagName   : 'section'
    className : 'graph'
    template  : require 'kraken/template/graph'
    
    events:
        'click    .redraw-button'                  : 'render'
        'click    .save-button'                    : 'save'
        # 'click    .load-button'                    : 'load'
        'keypress form.details input[type="text"]' : 'onKeypress'
        'keypress form.options .value'             : 'onKeypress'
        'submit   form.details'                    : 'onDetailsSubmit'
        'submit   form.options'                    : 'onOptionsSubmit'
        'change   input[type="checkbox"]'          : 'onOptionsSubmit'
    
    ready: false
    
    
    
    initialize : (o={}) ->
        @model or= new VisModel
        BaseView::initialize ...
        # console.log "#this.initialize!"
        
        for name of @__debounce__
            @[name] = _.debounce @[name], DEBOUNCE_RENDER
        
        # Resize graph on window resize
        # Note: can't debounce the method itself, as the debounce wrapper returns undefined
        $ root .on 'resize', _.debounce(@resizeViewport, DEBOUNCE_RENDER)
        
        @id = _.domize 'graph', (@model.get('slug', @model.id or @model.cid))
        
        @model.on 'destroy', @remove, this
        @model.on 'change',  @render, this
        @model.on 'change:dataset', @onModelChange
        @model.on 'change:options', @onModelChange
        
        # Rerender the options boxes once the tab is visible
        @$el.on 'click', '.graph-options-tab', @onFirstClickRenderOptionsTab
        
        @viewport = @$el.find '.viewport'
        
        @scaffold = new GraphOptionsScaffold
        @$el.find '.graph-options-pane' .append @scaffold.el
        @scaffold.collection.reset that if o.graph_spec
        
        @scaffold.on 'change', @onScaffoldChange
        
        options = @model.getOptions()
        @chartOptions options, {+silent}
        
        @resizeViewport()
        _.delay @onReady, DEBOUNCE_RENDER
    
    
    change: ->
        @model.change()
        @scaffold.invoke 'change'
        this
    
    save: ->
        console.log "#this.save!"
        $.ajax do
            url  : '/graph/save'
            type : 'POST'
            data : @toJSON()
            success : (response) ->
                console.log 'saved!'
            error : (err) ->
                console.error "error!", arguments
    
    
    chartOptions: (values, opts) ->
        # Handle @chartOptions(k, v, opts)
        if arguments.length > 1 and typeof values is 'string'
            [k, v, opts] = arguments
            values = { "#k": v }
        
        fields = @scaffold.collection
        if values
            for k, v in values
                fields.get(k)?.setValue v, opts
            this
        else
            options = @model.getOptions {-keepDefaults, +keepUnchanged}
            for k of @FILTER_CHART_OPTIONS
                # console.log "filter #k?", not options[k]
                if k in options and not options[k]
                    delete options[k]
            options
    
    /**
     * Resizes chart according to the model's width and height.
     * @return { width, height }
     */
    resizeViewport: ->
        modelW = width  = @model.get 'width'
        modelH = height = @model.get 'height'
        return { width, height } unless @ready
        
        # Remove old style, as it confuses dygraph after options update
        @viewport.attr 'style', ''
        label = @$el.find '.graph-label'
        
        if width is 'auto'
            vpWidth = @viewport.innerWidth()
            labelW = label.outerWidth()
            width = vpWidth - labelW - 10 - (vpWidth - label.position().left - labelW)
        width ?= modelW
        if height is 'auto'
            height = @viewport.innerHeight()
        height ?= modelH
        
        size = { width, height }
        @viewport.css size
        # console.log 'resizeViewport!', JSON.stringify(size), @viewport
        # @chart.resize size if forceRedraw
        size
    
    
    
    render: ->
        return this unless @ready
        
        dataset = @model.get 'dataset'
        size    = @resizeViewport()
        
        # XXX: use @model.changedAttributes() to calculate what to update
        options = @chartOptions() #import size
        options import do
            labelsDiv          : @$el.find '.graph-label' .0
            # axisLabelFormatter : @axisFormatter
            # valueFormatter     : @formatter
        
        # console.log "#this.render!", dataset
        _.dump options, 'options'
        
        # Always rerender the chart to sidestep the case where we need to push defaults into
        # dygraphs to reset the current option state.
        @chart?.destroy()
        @chart = new Dygraph do
            @viewport.0
            dataset
            options
        # unless @chart
        #     @chart = new Dygraph do
        #         @viewport.0
        #         dataset
        #         options
        # else
        #     @chart.updateOptions options
        #     @chart.resize size
        
        @updateURL()
        this
    
    renderAll: ->
        return this unless @ready
        # console.log "#this.renderAll!"
        _.invoke @scaffold.subviews, 'render'
        @scaffold.render()
        @render()
        this
    
    /**
     * Update the page URL using HTML5 History API
     */
    updateURL: ->
        data  = @toJSON()
        title = @model.get('name', root.document?.title or '')
        url   = @toURL()
        # console.log 'History.pushState', JSON.stringify(data), title, url
        History.pushState data, title, url
    
    
    
    ### Formatters {{{
    
    axisFormatter: (n, granularity, opts, g) ->
        @formatter n, opts, g
    
    formatter: (n, opts, g) ->
        return n if n instanceof Date
        sigFigs = opts 'sigFigs'
        maxW    = opts 'maxNumberWidth'
        digits  = opts 'digitsAfterDecimal'
        v = Dygraph.round_ n, digits
        # Dygraph.floatFormat n, sigFigs
        # console.log n, "->", v, "?= %#{maxW}.#{digits}g (sigFigs=#sigFigs)"
        v
    
    
    ### }}}
    ### Event Handlers {{{
    
    onReady: ->
        # console.log "(#this via VisView).ready!"
        @ready = @scaffold.ready = true
        # @change()
        @model.change()
        @renderAll()
    
    onModelChange: ->
        changes = @model.changedAttributes()
        # console.log 'VisModel.changed( options ) ->', JSON.stringify changes
        @chart.updateOptions file:that if changes?.dataset
        @chartOptions that, {+silent} if changes?.options
    
    onScaffoldChange: (scaffold, value, key, field) ->
        current = @model.getOption(key)
        # console.log do
        #     "scaffold.change! #key:"
        #     current
        #     '-->'
        #     value
        #     " ( isDefault?"
        #     (current is void and field.isDefault())
        #     "isEqual?"
        #     _.isEqual(value, current)
        #     ")   --> "
        #     unless _.isEqual(value, current) or (current is void and field.isDefault()) then 'CHANGE' else 'SQUELCH'
        
        unless _.isEqual(value, current) or (current is void and field.isDefault())
            @model.setOption(key, value, {+silent})
    
    onFirstClickRenderOptionsTab: ->
        @$el.off 'click', '.graph-options-tab', @onFirstClickRenderOptionsTab
        @scaffold.render()
    
    onKeypress: (evt) ->
        $(evt.target).submit() if evt.keyCode is 13
    
    onDetailsSubmit: ->
        console.log "#this.onDetailsSubmit!"
        data = _.synthesize do
            @$el.find('form.details').serializeArray()
            -> [it.name, it.value]
        @model.set data
        false
    
    onOptionsSubmit: ->
        console.log "#this.onOptionsSubmit!"
        @render()
        false
    
    # }}}
    
    toString: -> "#{@ctorName}(#{@model})"
# }}}

