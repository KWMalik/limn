moment = require 'moment'

_ = require 'kraken/util/underscore'
{ BaseView,
} = require 'kraken/base'
{ ChartOptionScaffold, DEBOUNCE_RENDER,
} = require 'kraken/chart'
{ Graph,
} = require 'kraken/graph/graph-model'
{ DataView, DataSetView, DataSet,
} = require 'kraken/dataset'

root = do -> this




/**
 * @class View for a graph visualization encapsulating the editing UI for:
 * - Graph metadata, such as name, description, slug
 * - Chart options, using ChartOptionScaffold
 */
GraphEditView = exports.GraphEditView = BaseView.extend do # {{{
    FILTER_CHART_OPTIONS : <[ 
        file labels visibility colors dateWindow ticker timingName xValueParser
        axisLabelFormatter xAxisLabelFormatter yAxisLabelFormatter
        valueFormatter xValueFormatter yValueFormatter
    ]>
    __bind__  : <[
        render renderAll stopAndRender stopAndRenderAll resizeViewport wait unwait checkWaiting
        numberFormatter numberFormatterHTML
        onReady onSync onModelChange onScaffoldChange onFirstClickRenderOptionsTab
    ]>
    __debounce__: <[ render renderAll ]>
    tagName   : 'section'
    className : 'graph graph-edit'
    template  : require 'kraken/template/graph-edit'
    
    events:
        'click    .redraw-button'                  : 'stopAndRender'
        'click    .load-button'                    : 'load'
        'click    .save-button'                    : 'save'
        'click    .done-button'                    : 'done'
        'keypress form.details input[type="text"]' : 'onKeypress'
        'keypress form.options .value'             : 'onKeypress'
        'submit   form.details'                    : 'onDetailsSubmit'
        'change   select'                          : 'onDetailsSubmit'
        'submit   form.options'                    : 'onOptionsSubmit'
        'change   input[type="checkbox"]'          : 'onOptionsSubmit'
    
    
    /**
     * Count of outstanding tasks until we stop the spinner.
     * @type Number
     */
    waitingOn : 0
    
    /**
     * Whether we're ready.
     * @type Boolean
     */
    ready : false
    
    
    
    constructor: function GraphEditView
        BaseView ...
    
    initialize : (o={}) ->
        # @data = {}
        @model or= new Graph
        @id = @graph_id = _.domize 'graph', (@model.id or @model.get('slug') or @model.cid)
        BaseView::initialize ...
        # console.log "#this.initialize!"
        
        for name of @__debounce__
            @[name] = _.debounce @[name], DEBOUNCE_RENDER
        
        # Set up the spinner
        @on 'start-waiting', @onStartWaiting, this
        @on 'stop-waiting',  @onStopWaiting,  this
        @onStartWaiting() if @waitingOn # In case we missed the first call to @wait() somehow
        
        # Start a wait for the `ready` event
        @wait()
        
        ### Model Events
        @model
            .on 'start-waiting',    @wait,          this
            .on 'stop-waiting',     @unwait,        this
            .on 'sync',             @onSync,        this
            .on 'destroy',          @remove,        this
            .on 'change',           @render,        this
            .on 'change:dataset',   @onModelChange, this
            .on 'change:options',   @onModelChange, this
            .on 'error',            @onModelError,  this
            .on 'ready',            @onReady,       this
        
        ### Chart Options Tab, Scaffold
        @scaffold = @addSubview '.graph-options-pane', new ChartOptionScaffold
        @$el.find '.graph-options-pane' .append @scaffold.el
        @scaffold.collection.reset that if o.graph_spec
        
        @scaffold.on 'change', @onScaffoldChange
        @chartOptions @model.getOptions(), {+silent}
        
        # Rerender the options boxes once the tab is visible
        # Can't use @events because we need to bind before registering
        @$el.on 'click', '.graph-options-tab', @onFirstClickRenderOptionsTab
        
        ### Graph Data UI
        @data = @addSubview '.graph-data-pane', new DataView { model:@model.get('dataset'), graph_id:@id }
        @$el.find '.graph-data-pane' .append @data.render().el
        @data
            .on 'change',        @onDataChange, this
            .on 'start-waiting', @wait,         this
            .on 'stop-waiting',  @unwait,       this
        
        @checkWaiting()
        
        ### Chart Viewport
        @resizeViewport()
        
        # Resize chart on window resize
        # Note: can't debounce the method itself, as the debounce wrapper returns undefined
        $ root .on 'resize', _.debounce @resizeViewport, DEBOUNCE_RENDER
    
    
    
    
    ### Persistence {{{
    
    load: ->
        console.log "#this.load!"
        @wait()
        @model.fetch { success:@unwait, error:@unwait }
        false
    
    save: ->
        console.log "#this.save!"
        @wait()
        id = @model.get('slug') or @model.id
        @model.save {id}, { +wait, success:@unwait, error:@unwait }
        false
    
    done: ->
        @save()
    
    change: ->
        @model.change()
        @scaffold.invoke 'change'
        this
    
    
    ### }}}
    ### Rendering {{{
    
    chartOptions: (values, opts) ->
        # Handle @chartOptions(k, v, opts)
        if arguments.length > 1 and typeof values is 'string'
            [k, v, opts] = arguments
            values = { "#k": v }
        
        fields = @scaffold.collection
        if values
            for k, v in values
                fields.get(k)?.setValue v, opts
            this
        else
            options = @model.getOptions {-keepDefaults, +keepUnchanged}
            for k of @FILTER_CHART_OPTIONS
                # console.log "filter #k?", not options[k]
                if k in options and not options[k]
                    delete options[k]
            options
    
    toTemplateLocals: ->
        attrs = _.clone @model.attributes
        delete attrs.options
        # delete attrs.dataset
        # attrs.data = @data
        { $, _, op, @model, view:this, @graph_id, slug:'', name:'', desc:'' } import attrs
    
    
    /**
     * Resizes chart according to the model's width and height.
     * @return { width, height }
     */
    resizeViewport: ->
        modelW = width  = @model.get 'width'
        modelH = height = @model.get 'height'
        return { width, height } unless @ready
        
        viewport = @$el.find '.viewport'
        
        # Remove old style, as it confuses dygraph after options update
        viewport.attr 'style', ''
        label = @$el.find '.graph-label'
        
        if width is 'auto'
            vpWidth = viewport.innerWidth()
            labelW = label.outerWidth()
            width = vpWidth - labelW - 10 - (vpWidth - label.position().left - labelW)
        width ?= modelW
        if height is 'auto'
            height = viewport.innerHeight()
        height ?= modelH
        
        size = { width, height }
        viewport.css size
        # console.log 'resizeViewport!', JSON.stringify(size), viewport
        # @chart.resize size if forceRedraw
        size
    
    
    # Repopulate UI from Model
    renderDetails: ->
        form = @$el.find 'form.details'
        for k, v in @model.attributes
            continue if k is 'options'
            txt = @model.serialize v
            
            el = form.find "input[name=#k]"
            if el.attr('type') is 'checkbox'
                el.attr 'checked', if v then 'checked' else ''
            else
                el.val txt
            
            form.find "textarea[name=#k]" .text txt
        
        # Graph Name field is not part of the form due to the layout.
        @$el.find "input.graph-name[name='name']" .val @get 'name'
        this
    
    # Redraw chart inside viewport.
    renderChart: ->
        data = @model.get 'dataset'
        data = data.getData() if typeof data is not 'string'
        size = @resizeViewport()
        
        # XXX: use @model.changedAttributes() to calculate what to update
        options = @chartOptions() #import size
        options import do
            labelsDiv          : @$el.find '.graph-label' .0
            valueFormatter     : @numberFormatterHTML
            axes:
                x:
                    axisLabelFormatter : @axisDateFormatter
                    valueFormatter     : @dateFormatter
                y:
                    axisLabelFormatter : @axisFormatter @numberFormatter
                    valueFormatter     : @numberFormatterHTML
        
        # console.log "#this.render!", dataset
        _.dump options, 'options'
        
        # Always rerender the chart to sidestep the case where we need to push defaults into
        # dygraphs to reset the current option state.
        @chart?.destroy()
        @chart = new Dygraph do
            @$el.find '.viewport' .0
            data
            options
        
        # unless @chart
        #     @chart = new Dygraph do
        #         @$el.find '.viewport' .0
        #         data
        #         options
        # else
        #     @chart.updateOptions options
        #     @chart.resize size
        
        this
    
    attachSubviews: ->
        @$el.find '.graph-options-pane' .append @scaffold.el        if @scaffold
        @$el.find '.graph-data-pane'    .append @data.render().el   if @data
        @checkWaiting()
    
    render: ->
        return this unless @ready
        @wait()
        @checkWaiting() # fix up the spinner element as the DOM is now settled
        @renderDetails()
        @attachSubviews()
        # _.invoke @subviews, 'render'
        @renderChart()
        @updateURL()
        @trigger 'render', this
        @unwait()
        this
    
    renderAll: ->
        return this unless @ready
        # console.log "#this.renderAll!"
        @wait()
        _.invoke @scaffold.subviews, 'render'
        @scaffold.render()
        @render()
        @unwait()
    
    
    /**
     * Update the page URL using HTML5 History API
     */
    updateURL: ->
        data  = @toJSON()
        title = "#{@model.get('name') or 'New Graph'} | Edit Graph | GraphKit"
        url   = @toURL()
        # console.log 'History.pushState', JSON.stringify(data), title, url
        History.pushState data, title, url
    
    
    /**
     * Retrieve or construct the spinner.
     */
    spinner: ->
        el = @$el.find '.graph-spinner'
        unless el.data 'spinner'
            ### Spin.js Options ###
            opts =
                lines     : 9           # [12]        The number of lines to draw
                length    : 2           # [7]         The length of each line
                width     : 1           # [5]         The line thickness
                radius    : 7           # [10]        The radius of the inner circle
                rotate    : -10.5       # [0]         rotation offset
                trail     : 50          # [100]       Afterglow percentage
                opacity   : 1/4         # [1/4]       Opacity of the lines
                shadow    : false       # [false]     Whether to render a shadow
                speed     : 1           # [1]         Spins per second
                zIndex    : 2e9         # [2e9]       zIndex; uses a very high z-index by default
                color     : '#000'      # ['#000']    Line color; '#rgb' or '#rrggbb'.
                top       : 'auto'      # ['auto']    Top position relative to parent in px; 'auto' = center vertically.
                left      : 'auto'      # ['auto']    Left position relative to parent in px; 'auto' = center horizontally.
                className : 'spinner'   # ['spinner'] CSS class to assign to the element
                fps       : 20          # [20]        Frames per second when falling back to `setTimeout()`.
                hwaccel   : Modernizr.csstransforms3d   # [false]     Whether to use hardware acceleration.
            
            isHidden = el.css('display') is 'none'
            el.show().spin opts
            el.hide() if isHidden
        el
    
    checkWaiting: ->
        spinner = @spinner()
        if isWaiting = (@waitingOn > 0)
            spinner.show()
            if spinner.find('.spinner').css('top') is '0px'
                # delete spinner
                spinner.spin(false)
                # re-add to DOM with correct parent sizing
                @spinner()
        else
            spinner.hide()
        isWaiting
    
    
    ### }}}
    ### Formatters {{{
    
    axisFormatter: (fmttr) ->
        (n, granularity, opts, g) -> fmttr n, opts, g
    
    axisDateFormatter: (n, granularity, opts, g) ->
        moment(n).format 'MM/YYYY'
    
    dateFormatter: (n, opts, g) ->
        moment(n).format 'DD MMM YYYY'
    
    _numberFormatter: (n, digits=2) ->
        for [suffix, d] of [['B', 1000000000], ['M', 1000000], ['K', 1000], ['', NaN]]
            if n >= d
                n = n / d
                break
        s = n.toFixed(digits)
        parts = s.split '.'
        whole = _.rchop parts[0], 3 .join ','
        fraction = '.' + parts.slice(1).join '.'
        { n, digits, whole, fraction, suffix }
    
    numberFormatter: (n, opts, g) ->
        digits = opts('digitsAfterDecimal') ? 2
        { whole, fraction, suffix } = @_numberFormatter n, digits
        "#whole#fraction#suffix"
    
    numberFormatterHTML: (n, opts, g) ->
        digits = opts('digitsAfterDecimal') ? 2
        { whole, fraction, suffix } = @_numberFormatter n, digits
        # coco will trim all the whitespace
        "<span class='value'>
        <span class='whole'>#whole</span>
        <span class='fraction'>#fraction</span>
        <span class='suffix'>#suffix</span>
        </span>"
    
    ### }}}
    ### Event Handlers {{{
    
    onReady: ->
        return if @ready
        # $.getJSON '/datasources/all', (@data) ~>
        console.log "(#this via GraphEditView).ready!"
        @ready = @scaffold.ready = true
        @unwait() # clears `wait()` from `initialize`
        @onSync()
        
        # fix up the spinner element once the DOM is settled
        _.delay @checkWaiting, 50
    
    onSync: ->
        return unless @ready
        console.info "#this.sync() --> success!"
        # TODO: UI alert
        # @change()
        # @model.change()
        @chartOptions @model.getOptions(), {+silent}
        @renderAll()
    
    onStartWaiting: ->
        console.log "#this.onStartWaiting!", @checkWaiting()
    
    onStopWaiting: ->
        console.log "#this.onStopWaiting!", @checkWaiting()
    
    onModelError: ->
        console.error "#this.error!", arguments
        # TODO: UI alert
    
    onModelChange: ->
        changes = @model.changedAttributes()
        options = @model.getOptions()
        # console.log """
        #     Graph.changed( options ) ->
        #     \tchanges: #{JSON.stringify changes}
        #     \toptions: #{JSON.stringify options}
        #     \t^opts: #{JSON.stringify _.intersection _.keys(changes), _.keys(options)}
        # """
        @chart?.updateOptions file:that if changes?.dataset
        @chartOptions options, {+silent} if changes?.options
    
    onScaffoldChange: (scaffold, value, key, field) ->
        current = @model.getOption(key)
        # console.log do
        #     "scaffold.change! #key:"
        #     current
        #     '-->'
        #     value
        #     " ( isDefault?"
        #     (current is void and field.isDefault())
        #     "isEqual?"
        #     _.isEqual(value, current)
        #     ")   --> "
        #     unless _.isEqual(value, current) or (current is void and field.isDefault()) then 'CHANGE' else 'SQUELCH'
        
        unless _.isEqual(value, current) or (current is void and field.isDefault())
            @model.setOption(key, value, {+silent})
    
    onDataChange: ->
        console.log 'onDataChange!'
    
    onFirstClickRenderOptionsTab: ->
        @$el.off 'click', '.graph-options-tab', @onFirstClickRenderOptionsTab
        @scaffold.render()
    
    onKeypress: (evt) ->
        $(evt.target).submit() if evt.keyCode is 13
    
    onDetailsSubmit: ->
        console.log "#this.onDetailsSubmit!"
        data = _.synthesize do
            @$el.find('form.details').serializeArray()
            -> [it.name, it.value]
        @model.set data
        false
    
    onOptionsSubmit: ->
        console.log "#this.onOptionsSubmit!"
        @render()
        false
    
    # Needed because (sigh) _.debounce returns undefined, and we need to preventDefault()
    stopAndRender    : -> @render ... ;     false
    stopAndRenderAll : -> @renderAll ... ;  false
    
    # }}}
    
# }}}

