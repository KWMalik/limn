_ = require 'kraken/underscore'
{ BaseModel, BaseView,
} = require 'kraken/base'
{ Field, FieldList, FieldView, Scaffold
} = require 'kraken/scaffold'



class exports.TagSet extends Array
    tags : {}
    
    (values=[]) ->
        @tags = {}
        @add values if values?.length
    
    has: (tag) ->
        @tags[tag]?
    
    get: (tag) ->
        return -1 unless tag
        unless @tags[tag]?
            @tags[tag] = @length
            @push tag
        @tags[tag]
    
    update: (tags) ->
        is_single = typeof tags is 'string'
        tags      = [tags] if is_single
        indices   = ( for tag of tags then @get tag )
        if is_single then indices[0] else indices
    
    toString: -> "TagSet(length=#{@length}, values=[\"#{@join '", "'}\"])"


KNOWN_TAGS = exports.KNOWN_TAGS = new TagSet()


/**
 * Field with graph-option-specific handling for validation, parsing, tags, etc.
 */
GraphOption = exports.GraphOption = Field.extend do # {{{
    ctorName : 'GraphOption'
    
    initialize : ->
        # console.log "#this.initialize!"
        Field::initialize ...
        
        # Notify Tag indexer of category when created, to ensure all category-tags
        # get indices with colors :P
        KNOWN_TAGS.update @getCategory()
    
    
    # Wrapper to ensure @set('tags') is called, as tags.push()
    # will not trigger the 'changed:tags' event.
    addTag: (tag) ->
        return this unless tag
        tags = @get('tags', [])
        tags.push tag
        @set 'tags', tags
        this
    
    # Wrapper to ensure @set('tags') is called, as tags.push()
    # will not trigger the 'changed:tags' event.
    removeTag: (tag) ->
        return this unless tag
        tags = @get('tags', [])
        _.remove tags, tag
        @set 'tags', tags
        this
    
    # Keep tag list up to date
    onTagUpdate: ->
        KNOWN_TAGS.update @get 'tags'
        this
    
    getTagIndex: (tag) ->
        KNOWN_TAGS.get tag
    
    # A field's category is its first tag.
    getCategory: ->
        @get('tags', [])[0]
    
    getCategoryIndex: ->
        @getTagIndex @getCategory()
    
    
    toJSON: ->
        o = Field::toJSON ...
        for k, v in o
            o[k] = '' if v!?
        o
    
    toKVPairs: ->
        key = @get 'name'
        value = @get 'value'
        if value?
            "#{encodeURIComponent key}=#{encodeURIComponent value}"
        else
            ''
    

# }}}


GraphOptionList = exports.GraphOptionList = FieldList.extend do # {{{
    ctorName   : 'GraphOptionList'
    model      : GraphOption
    
    /**
     * Transforms this list into form-encoded KV-pairs, excluding null values and 
     * @returns {String}
     */
    toKVPairs: (keepDefaults=false) ->
        @models
            .filter -> it.get('name') and it.getValue()? and (keepDefaults or not it.isDefault())
            .map -> "#{encodeURIComponent it.get 'name'}=#{encodeURIComponent it.serializeValue()}"
            .join '&'
    
# }}}


/**
 * Represents a Graph, including its charting options, dataset, annotations, and all
 * other settings for both its content and presentation.
 */
GraphModel = exports.GraphModel = BaseModel.extend do # {{{
    ctorName : 'GraphModel'
    urlRoot  : '/graphs'
    
    initialize : ->
        name = @get 'name'
        if name and not (@id or @has 'id')
            @id = @attributes.id = _.underscored name
    
    defaults : ->
        {
            name    : 'Kraken Graph'
            dataset : '/data/page_views_by_language.csv'
            options : { stackedGraph:1 }
        }
    
    
    hasOption: (key) ->
        options = @get 'options', {}
        key in options
    
    getOption: (key, def) ->
        options = @get 'options', {}
        if key in options then options[key] else def
    
    setOption: (key, value, opts={}) ->
        options = @get 'options', {}
        options[key] = value
        @set 'options', options, opts
        @trigger "change:options:#key", this, value, key, opts unless opts.silent
    
    unsetOption: (key, opts={}) ->
        options = @get 'options', {}
        delete options[key]
        @set 'options', options, opts
        @trigger "change:options:#key", this, value, key, opts unless opts.silent
    
    
    toKVPairs: ->
        ...
    
    toString: -> "#{@ctorName}(id=#{@id}, name=#{@get 'name'}, dataset=#{@get 'dataset'})"
# }}}


