moment = require 'moment'

_ = require 'kraken/util/underscore'
{ BaseView,
} = require 'kraken/base'
{ Graph,
} = require 'kraken/graph/graph-model'

root = do -> this
DEBOUNCE_RENDER = 100ms




/**
 * @class Base view for a Graph visualizations.
 */
GraphView = exports.GraphView = BaseView.extend do # {{{
    FILTER_CHART_OPTIONS : <[ 
        file labels visibility colors dateWindow ticker timingName xValueParser
        axisLabelFormatter xAxisLabelFormatter yAxisLabelFormatter
        valueFormatter xValueFormatter yValueFormatter
    ]>
    __bind__  : <[
        render stopAndRender resizeViewport checkWaiting
        numberFormatter numberFormatterHTML
        onReady onSync onModelChange
    ]>
    __debounce__: <[ render ]>
    tagName   : 'section'
    
    /**
     * The chart type backing this graph.
     * @type ChartType
     */
    chartType : null
    
    
    
    constructor: function GraphView
        BaseView ...
    
    initialize : (o={}) ->
        @model or= new Graph
        @id = @graph_id = _.domize 'graph', (@model.id or @model.get('slug') or @model.cid)
        @chartType = @model.chartType.withView this
        GraphView.__super__.initialize ...
        
        for name of @__debounce__
            @[name] = _.debounce @[name], DEBOUNCE_RENDER
        
        # Set up the spinner
        @on 'start-waiting', @onStartWaiting, this
        @on 'stop-waiting',  @onStopWaiting,  this
        @onStartWaiting() if @waitingOn # In case we missed the first call to @wait() somehow
        
        ### Model Events
        @model
            .on 'start-waiting',    @wait,          this
            .on 'stop-waiting',     @unwait,        this
            .on 'sync',             @onSync,        this
            .on 'destroy',          @remove,        this
            .on 'change',           @render,        this
            .on 'change:dataset',   @onModelChange, this
            .on 'change:options',   @onModelChange, this
            .on 'error',            @onModelError,  this
        
        ### Chart Viewport
        @resizeViewport()
        
        # Resize chart on window resize
        # Note: can't debounce the method itself, as the debounce wrapper returns undefined
        $ root .on 'resize', _.debounce @resizeViewport, DEBOUNCE_RENDER
    
    loadData: ->
        @resizeViewport()
        @wait()
        Seq()
            .seq_ (next) ~>
                @chartType.once 'ready', next.ok
            .seq_ (next) ~>
                @model.once 'ready', next.ok .load()
            .seq_ (next) ~>
                @model.once 'data-ready', next.ok .loadData()
            .seq ~>
                @unwait()
                @onReady()
    
    
    ### Persistence {{{
    
    /**
     * Reload the graph definition from the server.
     */
    load: ->
        console.log "#this.load!"
        @wait()
        @model.fetch { success:@unwait, error:@unwait }
        false
    
    /**
     * Save the graph definition to the server.
     */
    save: ->
        console.log "#this.save!"
        @wait()
        id = @model.get('slug') or @model.id
        @model.save {id}, { +wait, success:@unwait, error:@unwait }
        false
    
    /**
     * Flush all changes.
     */
    change: ->
        @model.change()
        this
    
    
    ### Rendering {{{
    
    chartOptions: (values, opts) ->
        # Handle @chartOptions(k, v, opts)
        if arguments.length > 1 and typeof values is 'string'
            [k, v, opts] = arguments
            values = { "#k": v }
        values or= {}
        
        options = @model.getOptions {-keepDefaults, +keepUnchanged}
        for k of @FILTER_CHART_OPTIONS
            # console.log "filter #k?", not options[k]
            if k in options and not options[k]
                delete options[k]
        options
    
    
    toTemplateLocals: ->
        attrs = _.extend {}, @model.attributes
        delete attrs.options
        { @model, view:this, @graph_id, slug:'', name:'', desc:'' } import attrs
    
    
    /**
     * Resizes chart according to the model's width and height.
     * @return { width, height }
     */
    resizeViewport: ->
        modelW = width  = @model.get 'width'
        modelH = height = @model.get 'height'
        return { width, height } unless @ready
        
        # Remove old style, as it confuses dygraph after options update
        viewport = @$ '.viewport'
        viewport.attr 'style', ''
        label = @$ '.graph-legend'
        
        if width is 'auto'
            vpWidth = viewport.innerWidth() or 300
            labelW = label.outerWidth() or 228
            width = vpWidth - labelW - 10 - (vpWidth - label.position().left - labelW)
        width ?= modelW
        if height is 'auto'
            height = viewport.innerHeight() or 320
        height ?= modelH
        
        size = { width, height }
        viewport.css size
        # console.log 'resizeViewport!', JSON.stringify(size), viewport
        # @chart.resize size if forceRedraw
        size
    
    
    /**
     * Redraw chart inside viewport.
     */
    renderChart: ->
        # data = @model.get 'dataset'
        # data = data.getData() if typeof data is not 'string'
        dataset = @model.dataset
        data = dataset.getData()
        size = @resizeViewport()
        
        # XXX: use @model.changedAttributes() to calculate what to update?
        options = @chartOptions() #import size
        options import do
            colors             : dataset.getColors()
            labels             : dataset.getLabels()
            labelsDiv          : @$ '.graph-legend' .0
            valueFormatter     : @numberFormatterHTML
            axes:
                x:
                    axisLabelFormatter : @axisDateFormatter
                    valueFormatter     : @dateFormatter
                y:
                    axisLabelFormatter : @axisFormatter @numberFormatter
                    valueFormatter     : @numberFormatterHTML
        
        # console.log "#this.render!", dataset
        # _.dump options, 'options'
        
        # Always rerender the chart to sidestep the case where we need to push defaults into
        # dygraphs to reset the current option state.
        @chart?.destroy()
        @chart = new Dygraph do
            @$ '.viewport' .0
            data
            options
        
        # unless @chart
        #     @chart = new Dygraph do
        #         @$ '.viewport' .0
        #         data
        #         options
        # else
        #     @chart.updateOptions options
        #     @chart.resize size
        
        this
    
    
    /**
     * Render the chart and other Graph-derived view components.
     */
    render: ->
        return this unless @ready
        @wait()
        @checkWaiting()
        GraphView.__super__.render ...
        
        # @renderChart()
        @chart = @chartType.render()
        
        @unwait()
        @checkWaiting()
        this
    
    
    ### }}}
    ### Formatters {{{
    
    # XXX: Dygraphs-specific
    axisFormatter: (fmttr) ->
        (n, granularity, opts, g) -> fmttr n, opts, g
    
    # XXX: Dygraphs-specific
    axisDateFormatter: (n, granularity, opts, g) ->
        moment(n).format 'MM/YYYY'
    
    # XXX: Dygraphs-specific
    dateFormatter: (n, opts, g) ->
        moment(n).format 'DD MMM YYYY'
    
    _numberFormatter: (n, digits=2) ->
        for [suffix, d] of [['B', 1000000000], ['M', 1000000], ['K', 1000], ['', NaN]]
            if n >= d
                n = n / d
                break
        s = n.toFixed(digits)
        parts = s.split '.'
        whole = _.rchop parts[0], 3 .join ','
        fraction = '.' + parts.slice(1).join '.'
        { n, digits, whole, fraction, suffix }
    
    # XXX: Dygraphs-specific
    numberFormatter: (n, opts, g) ->
        digits = opts('digitsAfterDecimal') ? 2
        { whole, fraction, suffix } = @_numberFormatter n, digits
        "#whole#fraction#suffix"
    
    # XXX: Dygraphs-specific
    numberFormatterHTML: (n, opts, g) ->
        digits = opts('digitsAfterDecimal') ? 2
        { whole, fraction, suffix } = @_numberFormatter n, digits
        # coco will trim the whitespace
        "<span class='value'>
        <span class='whole'>#whole</span>
        <span class='fraction'>#fraction</span>
        <span class='suffix'>#suffix</span>
        </span>"
    
    ### }}}
    ### Event Handlers {{{
    
    onSync: ->
        return unless @ready
        console.info "#this.sync() --> success!"
        # TODO: UI alert
        @chartOptions @model.getOptions(), {+silent}
        @render()
    
    onStartWaiting: ->
        status = @checkWaiting()
        # console.log "#this.onStartWaiting!", status
    
    onStopWaiting: ->
        status = @checkWaiting()
        # console.log "#this.onStopWaiting!", status
    
    onModelError: ->
        console.error "#this.error!", arguments
        # TODO: UI alert
    
    onModelChange: ->
        changes = @model.changedAttributes()
        options = @model.getOptions()
        # console.log """
        #     Graph.changed( options ) ->
        #     \tchanges: #{JSON.stringify changes}
        #     \toptions: #{JSON.stringify options}
        #     \t^opts: #{JSON.stringify _.intersection _.keys(changes), _.keys(options)}
        # """
        # @chart?.updateOptions file:that if changes?.dataset
        @chartOptions options, {+silent} if changes?.options
    
    # Needed because (sigh) _.debounce returns undefined, and we need to preventDefault()
    stopAndRender : -> @render ... ; false
    
    
    ### }}}
    ### Spinner {{{
    
    /**
     * Retrieve or construct the spinner.
     */
    spinner: ->
        el = @$ '.graph-spinner'
        unless el.data 'spinner'
            ### Spin.js Options ###
            opts =
                lines     : 9           # [12]        The number of lines to draw
                length    : 2           # [7]         The length of each line
                width     : 1           # [5]         The line thickness
                radius    : 7           # [10]        The radius of the inner circle
                rotate    : -10.5       # [0]         rotation offset
                trail     : 50          # [100]       Afterglow percentage
                opacity   : 1/4         # [1/4]       Opacity of the lines
                shadow    : false       # [false]     Whether to render a shadow
                speed     : 1           # [1]         Spins per second
                zIndex    : 2e9         # [2e9]       zIndex; uses a very high z-index by default
                color     : '#000'      # ['#000']    Line color; '#rgb' or '#rrggbb'.
                top       : 'auto'      # ['auto']    Top position relative to parent in px; 'auto' = center vertically.
                left      : 'auto'      # ['auto']    Left position relative to parent in px; 'auto' = center horizontally.
                className : 'spinner'   # ['spinner'] CSS class to assign to the element
                fps       : 20          # [20]        Frames per second when falling back to `setTimeout()`.
                hwaccel   : Modernizr.csstransforms3d   # [false]     Whether to use hardware acceleration.
            
            isHidden = el.css('display') is 'none'
            el.show().spin opts
            el.hide() if isHidden
        el
    
    checkWaiting: ->
        spinner = @spinner()
        if isWaiting = (@waitingOn > 0)
            spinner.show()
            if spinner.find('.spinner').css('top') is '0px'
                # delete spinner
                spinner.spin(false)
                # re-add to DOM with correct parent sizing
                @spinner()
        else
            spinner.hide()
        isWaiting
    
    # }}}
    

