Seq = require "seq"

_ = require 'kraken/util/underscore'
Cascade = require 'kraken/util/cascade'
{ ChartType,
} = require 'kraken/chart'
{ BaseModel, BaseList,
} = require 'kraken/base'
{ DataSet
} = require 'kraken/dataset'

root = do -> this



/**
 * Represents a Graph, including its charting options, dataset, annotations, and all
 * other settings for both its content and presentation.
 */
Graph = exports.Graph = BaseModel.extend do # {{{
    IGNORE_OPTIONS : <[ width height timingName ]>
    urlRoot        : '/graphs'
    
    /**
     * Whether this Graph has loaded all assets, parent-graphs, and related
     * resources.
     * @type Boolean
     */
    ready : false
    
    /**
     * The chart type backing this graph.
     * @type ChartType
     */
    chartType : null
    
    /**
     * List of graph parents.
     * @type GraphList
     */
    parents : null
    
    /**
     * Cascade of objects for options lookup (includes own options).
     * @type Cascade
     * @private
     */
    optionCascade : null
    
    
    
    
    /**
     * Attribute defaults.
     */
    defaults: ->
        {
            slug    : ''
            name    : ''
            desc    : ''
            notes   : ''
            # dataset : '/data/datasources/rc/rc_comscore_region_uv.csv'
            # dataset : null
            width   : 'auto'
            height  : 320
            chartType : 'dygraphs'
            parents : <[ root ]>
            options : {}
        }
    
    url: ->
        "#{@urlRoot}/#{@get('slug')}.json"
    
    
    
    constructor: function Graph (attributes={}, opts)
        # @on 'ready', ~> console.log "(#this via Graph).ready!"
        attributes.options or= {}
        @optionCascade = new Cascade attributes.options
        BaseModel.call this, attributes, opts
    
    
    initialize: (attributes, opts) ->
        BaseModel::initialize ...
        opts = {+autoload} import (opts or {})
        
        @constructor.register this
        @parents = new GraphList
        
        # TODO: Load on-demand
        @chartType = ChartType.lookup @get('chartType')
        
        # Insert submodels in place of JSON
        @set 'dataset', new DataSet(@get('dataset')), {+silent}
        
        @trigger 'init', this
        @load() if opts.autoload
    
    
    load: (opts={}) ->
        return this if @ready and not opts.force
        @wait()
        @trigger 'load', this
        Seq()
            .seq_ (next) ~>
                if @isNew()
                    next.ok()
                else
                    console.log "#{this}.fetch()..."
                    @wait()
                    @fetch do
                        error : @unwaitAnd (err) ~>
                            console.error "#{this}.fetch() --> error! #arguments"
                            next.ok()
                        success : @unwaitAnd (model, res) ~>
                            # console.log "#{this}.fetch() --> success!", res
                            next.ok res
            .seq_ (next) ~>
                next.ok @get('parents')
            .flatten()
            .seqMap_ (next, parent_id) ~>
                @wait()
                Graph.lookup parent_id, next
            .seqEach_ (next, parent) ~>
                @parents.add parent
                @optionCascade.addLookup parent.get('options')
                @unwait()
                next.ok()
            .seq ~>
                @ready = true
                @trigger 'ready', this
                @unwait() # terminates the `load` wait
        this
    
    
    
    ### Accessors
    
    get: (key) ->
        if _.startsWith key, 'options.'
            @getOption key.slice(8)
        else
            (@..__super__ or BaseModel::).get.call this, key
    
    
    set: (key, value, opts) ->
        # Handle @set(values, opts)
        if _.isObject(key) and key?
            [values, opts] = [key, value]
        else
            values = { "#key": value }
        values = @parse values
        
        setter = (@..__super__ or BaseModel::).set
        
        # Merge options in, firing granulated change events
        if values.options
            # Remove from values to prevent the super call to `set()` from
            # replacing the object wholesale.
            options = delete values.options
            
            # ...Unless we don't have one yet.
            if not @attributes.options
                setter.call this, {options}, {+silent}
            
            # Now delegate `setOption()` to do the nested merging.
            @setOption options, opts
        
        # Deal with everything else
        setter.call this, values, opts
    
    
    
    ### Chart Option Accessors ###
    
    hasOption: (key) ->
        @getOption(key) is void
    
    getOption: (key, def) ->
        @optionCascade.get key, def
    
    setOption: (key, value, opts={}) ->
        if _.isObject(key) and key?
            [values, opts] = [key, value or {}]
        else
            values = { "#key": value }
        
        # _.dump values, "#this.setOption"
        options = @get('options')
        changed = false
        for key, value in values
            continue if _.contains @IGNORE_OPTIONS, key
            changed = true
            _.setNested options, key, value, {+ensure}
            @trigger "change:options.#key", this, value, key, opts unless opts.silent
        
        if changed and not opts.silent
            @trigger "change:options", this, options, 'options', opts
        this
    
    unsetOption: (key, opts={}) ->
        unless @optionCascade.unset(key) is void or opts.silent
            @trigger "change:options.#key", this, void, key, opts
            @trigger "change:options", this, @get('options'), 'options', opts
        this
    
    getOptions: (opts={}) ->
        opts = {+keepDefaults, +keepUnchanged} import opts
        options = @optionCascade.toObject()
        for k, v in options
            delete options[k] if v is void or
                (not opts.keepDefaults  and @isDefaultOption k) or
                (not opts.keepUnchanged and not @isChangedOption k)
        options
    
    
    
    ### Serialization
    
    parse: (data) ->
        data = JSON.parse data if typeof data is 'string'
        for k, v in data
            data[k] = Number v if v is not 'auto' and _.contains <[ width height ]>, k
            # data[k] = JSON.stringify v if k is 'parents'
        data
    
    /**
     * @returns {Boolean} Whether the value for option `k` is inherited or not.
     */
    isOwnOption: (k) ->
        @optionCascade.isOwnValue k
    
    /**
     * @returns {Boolean} Whether the value for option `k` is the graph default or not.
     */
    isDefaultOption: (k) ->
        @chartType.isDefault k, @getOption k
    
    /**
     * Whether the value for option `k` differs from that of its parent graphs.
     * @returns {Boolean}
     */
    isChangedOption: (k) ->
        @optionCascade.isChangedValue k
        and not @isDefaultOption k
    
    
    toJSON: (opts={}) ->
        opts = {+keepDefaults, +keepUnchanged} import opts
        # use jQuery's deep-copy implementation -- XXX: Deep-copy no longer necessary thanks to @getOptions()
        # json = $.extend true, {}, @attributes
        json = _.clone(@attributes) import { options:@getOptions(opts) }
    
    
    toKVPairs: (opts={}) ->
        opts = {-keepSlug, -keepDefaults, -keepUnchanged} import opts
        
        # use jQuery's deep-copy implementation
        kvo = @toJSON opts
        kvo.parents = JSON.stringify kvo.parents
        delete kvo.slug unless opts.keepSlug
        
        # console.group 'toKVPairs'
        # console.log '[IN]', JSON.stringify kvo
        for k, v in kvo.options
            kvo.options[k] = @serialize v
        # console.log '[OUT]', JSON.stringify kvo
        # console.groupEnd()
        
        _.collapseObject kvo
    
    toKV: (opts) ->
        _.toKV @toKVPairs opts
    
    
    /**
     * @returns {String} URL identifying this model.
     */
    toURL: ->
        slug = @get('slug') or ''
        slug = "/#slug" if slug
        "#{@urlRoot}#slug?#{@toKV { keepSlug: !!slug }}"
    
# }}}


GraphList = exports.GraphList = BaseList.extend do # {{{
    urlRoot  : '/graphs'
    model    : Graph
    
    initialize : ->
        BaseList::initialize ...
    
    toString: ->
        modelIds = _.pluck @models, 'id' 
            .map -> "\"#it\""
            .join ', '
        "#{@..name or @..displayName}(#modelIds)"
# }}}


/* * * *  Visualization Cache for parent-lookup  * * * {{{ */

GRAPH_CACHE = exports.GRAPH_CACHE = new GraphList

Graph import do
    CACHE : GRAPH_CACHE
    
    register: (model) ->
        # console.log "#{@CACHE}.register(#{model.id or model.get('id')})", model
        if @CACHE.contains model
            @CACHE.remove model, {+silent}
        @CACHE.add model
        model
    
    get: (id) ->
        @CACHE.get id
    
    lookup: (id, cb) ->
        # console.log "#{@CACHE}.lookup(#id, #{typeof cb})"
        if @CACHE.get id
            cb null, that
        else
            Cls = this
            @register new Cls { id, slug:id }
                .on 'ready', -> cb null, it
    


_.bindAll Graph, 'register', 'get', 'lookup'

/* }}} */
