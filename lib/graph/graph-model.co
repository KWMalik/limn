Seq = require 'seq'

{ _, Cascade,
} = require 'kraken/util'
{ BaseModel, BaseList, ModelCache,
} = require 'kraken/base'
{ ChartType,
} = require 'kraken/chart'
{ DataSet
} = require 'kraken/dataset'

root = do -> this



/**
 * Represents a Graph, including its charting options, dataset, annotations, and all
 * other settings for both its content and presentation.
 */
Graph = exports.Graph = BaseModel.extend do # {{{
    IGNORE_OPTIONS : <[ width height timingName ]>
    urlRoot        : '/graphs'
    
    /**
     * Whether this Graph has loaded all assets, parent-graphs, and related
     * resources.
     * @type Boolean
     */
    ready : false
    
    /**
     * The chart type backing this graph.
     * @type ChartType
     */
    chartType : null
    
    /**
     * List of graph parents.
     * @type GraphList
     */
    parents : null
    
    /**
     * Cascade of objects for options lookup (includes own options).
     * @type Cascade
     * @private
     */
    optionCascade : null
    
    
    
    
    /**
     * Attribute defaults.
     */
    defaults: ->
        {
            slug    : ''
            name    : ''
            desc    : ''
            notes   : ''
            # dataset : '/data/datasources/rc/rc_comscore_region_uv.csv'
            # dataset : null
            width   : 'auto'
            height  : 320
            chartType : 'dygraphs'
            parents : <[ root ]>
            options : {}
        }
    
    url: ->
        "#{@urlRoot}/#{@get('slug')}.json"
    
    
    
    constructor: function Graph (attributes={}, opts)
        # @on 'ready', ~> console.log "(#this via Graph).ready!"
        attributes.options or= {}
        attributes.slug    or= attributes.id if attributes.id?
        @optionCascade = new Cascade attributes.options
        BaseModel.call this, attributes, opts
    
    
    initialize: (attributes, opts) ->
        BaseModel::initialize ...
        opts = {+autoload} import (opts or {})
        
        @constructor.register this
        @parents = new GraphList
        
        # TODO: Load on-demand
        @chartType = ChartType.lookup @get('chartType')
        
        # Insert submodels in place of JSON
        # data = @get('data') or @get('dataset')
        @set 'data', @dataset = new DataSet(@get('data')), {+silent}
        
        @trigger 'init', this
        @load() if opts.autoload
    
    
    load: (opts={}) ->
        return this if (@loading or @ready) and not opts.force
        @loading = true
        @wait()
        @trigger 'load', this
        Seq()
            .seq_ (next) ~>
                if @isNew()
                    next.ok()
                else
                    console.log "#{this}.fetch()..."
                    @wait()
                    @fetch do
                        error : @unwaitAnd (err) ~>
                            console.error "#{this}.fetch() --> error! #arguments"
                            next.ok()
                        success : @unwaitAnd (model, res) ~>
                            # console.log "#{this}.fetch() --> success!", res
                            @dataset.set @get('data')
                            @trigger 'change:data', this, @dataset, 'data'
                            @trigger 'change',      this, @dataset, 'data'
                            next.ok res
            .seq_ (next) ~>
                next.ok @get('parents')
            .flatten()
            .seqMap_ (next, parent_id) ~>
                @wait()
                Graph.lookup parent_id, next
            .seqEach_ (next, parent) ~>
                @parents.add parent
                @optionCascade.addLookup parent.get('options')
                @unwait()
                next.ok()
            .seq ~>
                @loading = false
                @unwait() # terminates the `load` wait
                @triggerReady()
        this
    
    
    
    ### Accessors
    
    get: (key) ->
        if _.startsWith key, 'options.'
            @getOption key.slice(8)
        else
            (@..__super__ or BaseModel::).get.call this, key
    
    
    set: (key, value, opts) ->
        # Handle @set(values, opts)
        if _.isObject(key) and key?
            [values, opts] = [key, value]
        else
            values = { "#key": value }
        values = @parse values
        
        setter = (@..__super__ or BaseModel::).set
        
        # Merge options in, firing granulated change events
        if values.options
            # Remove from values to prevent the super call to `set()` from
            # replacing the object wholesale.
            options = delete values.options
            
            # ...Unless we don't have one yet.
            if not @attributes.options
                setter.call this, {options}, {+silent}
            
            # Now delegate `setOption()` to do the nested merging.
            @setOption options, opts
        
        # Deal with everything else
        setter.call this, values, opts
    
    
    
    ### Chart Option Accessors ###
    
    hasOption: (key) ->
        @getOption(key) is void
    
    getOption: (key, def) ->
        @optionCascade.get key, def
    
    setOption: (key, value, opts={}) ->
        if _.isObject(key) and key?
            [values, opts] = [key, value or {}]
        else
            values = { "#key": value }
        
        # _.dump values, "#this.setOption"
        options = @get('options')
        changed = false
        for key, value in values
            continue if _.contains @IGNORE_OPTIONS, key
            changed = true
            _.setNested options, key, value, {+ensure}
            @trigger "change:options.#key", this, value, key, opts unless opts.silent
        
        if changed and not opts.silent
            @trigger "change:options", this, options, 'options', opts
        this
    
    unsetOption: (key, opts={}) ->
        unless @optionCascade.unset(key) is void or opts.silent
            @trigger "change:options.#key", this, void, key, opts
            @trigger "change:options", this, @get('options'), 'options', opts
        this
    
    inheritOption: (key, opts={}) ->
        old = @getOption(key)
        @optionCascade.inherit(key)
        unless @getOption(key) is old or opts.silent
            @trigger "change:options.#key", this, void, key, opts
            @trigger "change:options", this, @get('options'), 'options', opts
        this
    
    getOptions: (opts={}) ->
        opts = {+keepDefaults, +keepUnchanged} import opts
        options = @optionCascade.collapse()
        for k, v in options
            delete options[k] if v is void or
                (not opts.keepDefaults  and @isDefaultOption k) or
                (not opts.keepUnchanged and not @isChangedOption k)
        options
    
    
    
    ### Serialization
    
    parse: (data) ->
        data = JSON.parse data if typeof data is 'string'
        for k, v in data
            data[k] = Number v if v is not 'auto' and _.contains <[ width height ]>, k
            # data[k] = JSON.stringify v if k is 'parents'
        data
    
    /**
     * @returns {Boolean} Whether the value for option `k` is inherited or not.
     */
    isOwnOption: (k) ->
        @optionCascade.isOwnValue k
    
    /**
     * @returns {Boolean} Whether the value for option `k` is the graph default or not.
     */
    isDefaultOption: (k) ->
        @chartType.isDefault k, @getOption k
    
    /**
     * Whether the value for option `k` differs from that of its parent graphs.
     * @returns {Boolean}
     */
    isChangedOption: (k) ->
        @optionCascade.isModifiedValue k
        and not @isDefaultOption k
    
    
    toJSON: (opts={}) ->
        opts = {+keepDefaults, +keepUnchanged} import opts
        # use jQuery's deep-copy implementation -- XXX: Deep-copy no longer necessary thanks to @getOptions()
        # json = $.extend true, {}, @attributes
        json = _.clone(@attributes) import { options:@getOptions(opts) }
    
    
    toKVPairs: (opts={}) ->
        opts = {-keepSlug, -keepDefaults, -keepUnchanged} import opts
        
        # use jQuery's deep-copy implementation
        kvo = @toJSON opts
        kvo.parents = JSON.stringify kvo.parents
        delete kvo.slug unless opts.keepSlug
        delete kvo.data
        
        # console.group 'toKVPairs'
        # console.log '[IN]', JSON.stringify kvo
        for k, v in kvo.options
            kvo.options[k] = @serialize v
        # console.log '[OUT]', JSON.stringify kvo
        # console.groupEnd()
        
        _.collapseObject kvo
    
    toKV: (opts) ->
        _.toKV @toKVPairs opts
    
    
    /**
     * @returns {String} URL identifying this model.
     */
    toURL: (action) ->
        slug = @get 'slug'
        path = _.compact [ @urlRoot, slug, action ] .join '/'
        "#path?#{@toKV { keepSlug: !!slug }}"
    
    /**
     * @returns {String} Path portion of slug URL, e.g.  /graphs/:slug
     */
    toLink: ->
        "#{@urlRoot}/#{@get('slug')}"
    
    /**
     * @returns {String} Permalinked URI, e.g. http://reportcard.wmflabs.org/:slug
     */
    toPermalink: ->
        "#{root.location.protocol}//#{window.location.host}#{@toLink()}"
    
    
# }}}


GraphList = exports.GraphList = BaseList.extend do # {{{
    urlRoot  : '/graphs'
    model    : Graph
    
    constructor : function GraphList then BaseList ...
    initialize  : -> BaseList::initialize ...
    
    toString: ->
        modelIds = @models
            .map -> "\"#{it.id ? it.cid}\""
            .join ', '
        "#{@getClassName()}(#modelIds)"
# }}}


### Graph Cache for parent-lookup
new ModelCache Graph

