Seq = require 'seq'

{ _, op,
} = require 'kraken/util'
{ BaseView,
} = require 'kraken/base'
{ Graph, GraphList, GraphDisplayView,
} = require 'kraken/graph'
{ Dashboard,
} = require 'kraken/dashboard/dashboard-model'


/**
 * @class
 */
DashboardView = exports.DashboardView = BaseView.extend do # {{{
    __bind__       : <[  ]>
    tagName        : 'section'
    className      : 'dashboard'
    template       : require 'kraken/template/dashboard/dashboard'
    
    graph_ids : <[
        unique_visitors
        reach
        pageviews
        pageviews_mobile
        pageviews_mobile_target
        commons
        articles
        articles_per_day
        edits
        new_editors
        active_editors
        active_editors_target
        very_active_editors
    ]>
    
    core_tab :
        graph_ids : <[
        unique_visitors
        pageviews
        pageviews_mobile
        pageviews_mobile_target
        new_editors
        active_editors
        active_editors_target
    ]>
        name: ".core-graphs-pane"
    
    other_tab :
        graph_ids : <[
        reach
        commons
        articles
        articles_per_day
        edits
        very_active_editors
    ]>
        name: ".other-graphs-pane"
    
    dev_tab :
        graph_ids : <[
        mobile_devices
        mobile_devices_browsers
        mobile_devices_applications
    ]>
        name: ".dev-graphs-pane"
    
    events:
        # Select the whole permalink URI text when it receives focus.
        'click .graphs.tabbable .nav a' : 'onTabClick'
        'shown .graphs.tabbable .nav a' : 'onTabShown'
        # 'click  a[data-target="#other-graphs"]' : 'onTabShown'
        # 'click    .load-button'         : 'load'
    
    subviews : []
    graphs   : null
    ready    : false
    
    
    constructor: function DashboardView
        @subviews = []
        @graphs   = new GraphList
        Backbone.View ...
    
    initialize: ->
        @model or= new Dashboard
        BaseView::initialize ...
        # @graphs.on 'add', @attachGraphs, this
        # @graphs.on 'add', @attachGraph, this
        @load()
    
    
    # FIXME:
    #   - combine all loads into one seq so...
    #   - trigger ready when finished
    # TODO:
    #   - only render graph when scrolling makes it visible
    load: ->
        @addTab(@core_tab)
        @addTab(@other_tab)
        @addTab(@dev_tab)
    
    addTab: (tab) ->
        self = this
        Seq(tab.graph_ids)
            .parMap (id) ->
                Graph.lookup id, this
            .parMap (graph) ->
                self.graphs.add graph
                this null, new GraphDisplayView {model:graph}
            .parMap (view) ->
                return if view.isAttached
                graphs_el = self.$el.find tab.name
                graphs_el.append view.el
                self.subviews.push view
                view.isAttached = true
    
    
    ### Tabs {{{
    
    onTabShown: (e) ->
        Seq @subviews
            .parMap (view) ->
                # view.resizeViewport()
                view.renderChart()
    
    onTabClick: (evt) ->
        evt.preventDefault()
    
    
    ### }}}
    ### Navigation Between Graphs {{{
    
    /**
     * Scroll to the specified graph.
     * 
     * @param {String|Number|Graph} graph The Graph to scroll to; can be specified as a
     *  Graph id, an index into the Graphs list, or a Graph object.
     * @returns {this} 
     */
    scrollToGraph: (graph) ->
        if typeof graph is 'string'
            graph = @graphs.get graph
        else if typeof graph is 'number'
            graph = @graphs.at graph
        unless graph instanceof Graph
            console.error "#this.scrollToGraph() Unknown graph #graph!"
            return this
        
        return this unless view = _.find @subviews, -> it.model is graph
        $ 'body' .scrollTop view.$el.offset().top if view.$el.is ':visible'
        
        this
    
    findClosestGraph: (scroll) ->
        scroll or= $ 'body' .scrollTop()
        views = @subviews
            .filter -> it.$el.is ':visible'
            .map -> [ it.$el.offset().top, it ]
            .filter -> it[0] >= scroll
            .sort (a,b) -> op.cmp a[0], b[0]
        return views[0][1] if views.length
    
    ### }}}


