{ _, op,
} = require 'kraken/util'
{ BaseModel,
} = require 'kraken/base'
{ Graph, GraphList,
} = require 'kraken/graph/graph-model'


/**
 * @class
 */
Dashboard = exports.Dashboard = BaseModel.extend do # {{{
    urlRoot : '/dashboards'    
    
    # graph_ids : null
    graphs : null    
    # tabs : null
    
    
    constructor: function Dashboard
        @graphs = new GraphList
        BaseModel ...
    
    
    initialize: ->
        BaseModel::initialize ...
        @getGraphs null, ~> @triggerReady
    
    defaults: ->
        name : null
        tabs : [ { name:"Main", graph_ids:[] } ]
    
    
    graph_ids : <[
        unique_visitors
        reach
        pageviews
        pageviews_mobile
        pageviews_mobile_target
        commons
        articles
        articles_per_day
        edits
        new_editors
        active_editors
        active_editors_target
        very_active_editors
    ]>
    
    
    tabs : {
        core :
            graph_ids : <[
            unique_visitors
            pageviews
            pageviews_mobile
            pageviews_mobile_target
            new_editors
            active_editors
            active_editors_target
        ]>
            name: ".core-graphs-pane"
    
        other :
            graph_ids : <[
            reach
            commons
            articles
            articles_per_day
            edits
            very_active_editors
        ]>
            name: ".other-graphs-pane"
    
        dev :
            graph_ids : <[
            mobile_devices
            mobile_devices_browsers
            mobile_devices_applications
        ]>
            name: ".dev-graphs-pane"
    }
    
    addTab: (tabName) ->
        ...
    
    
    /**
     * Look up a tab.
     * 
     * @param {String|Number} tab Tab name or index.
     * @returns {Tab} Tab object.
     */
    getTab : (tab) ->
        tabs = @get 'tabs'
        return tabs[tab] if typeof tab is 'number'
        _.find tabs, -> it.name is tab
    
#    addGraph: (graph, tabName) ->
#        ...
    
    nest : (cb, records) ->
        console.log('[nest]\tentering')
        # console.log('[nest]\torig:')
        # console.log(records)
        graph_map = d3.nest()
            .key (graph_rec) ->
                graph_rec[0]
            .rollup (arr) -> 
                arr[0][1]
            .map(records)
        # console.log('[nest]\tnew:')
        # console.log(graph_map)
        cb null graph_map
    
    show : (cb, obj) ->
        console.log('[show]')
        console.log(obj)
        cb null, obj
    
    pushAsync : (cb, arr) ->
        (err, elem) ->
            arr.push elem
            cb null

    getGraphs : (err, cb) ->
        console.log('[getGraphs]\tentering')
        # consolidate graph_ids to one array
        graph_ids = _(@tabs).chain().values().map((tab_obj) -> tab_obj.graph_ids).flatten().value()
        
        Seq [graph_ids]
        .flatten()
        .parMap_ (next, graph_id) ->
            next null [graph_id]
        .parEach_ (next, graph_id_arr) ~>
            Graph.lookup graph_id_arr[0], @pushAsync next, graph_id_arr
            # Graph.lookup graph_id_arr[0], (err, el) ->
            #     graph_id_arr.push el
            #     next null
        # .parEach_ @show
        .unflatten()
        .seq_ (next, graph_tuples) ->
            # console.log('[setter]\tgraph_tuples:')
            # console.log(graph_tuples)
            @graphs = _.generate graph_tuples
            # console.log('[setter]\t@graphs:')
            # console.log(@graphs)            
            cb null
        # .parEach_ @show
        
        
    
# }}}