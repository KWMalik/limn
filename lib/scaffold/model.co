_    = require 'kraken/underscore'
op   = require 'kraken/util/op'
Hash = require 'hashish'



### Scaffold Models

class exports.Tags extends Array
    tags : {}
    
    (values=[]) ->
        @tags = {}
        @add values if values?.length
    
    has: (tag) ->
        @tags[tag]?
    
    get: (tag) ->
        return -1 unless tag
        unless @tags[tag]?
            @tags[tag] = @length
            @push tag
        @tags[tag]
    
    update: (tags) ->
        is_single = typeof tags is 'string'
        tags      = [tags] if is_single
        indices   = ( for tag of tags then @get tag )
        if is_single then indices[0] else indices
    
    toString: -> "Tags(length=#{@length}, values=[\"#{@join '", "'}\"])"


KNOWN_TAGS = exports.KNOWN_TAGS = new Tags()

Field = exports.Field = Backbone.Model.extend do # {{{
    ctorName    : 'Field'
    idAttribute : 'name'
    
    
    initialize: ->
        @set 'value', @get('default'), {+silent} if not @has 'value'
        
        # console.log "#this.initialize!"
        @on 'all', (evt) ~> console.log "#this.trigger(#evt)"
        
        # Notify Tag indexer of category when created, to ensure all category-tags
        # get indices with colors :P
        KNOWN_TAGS.update @getCategory()
    
    # Model defaults
    defaults: ->
        {
            name     : ''
            type     : 'String'
            default  : null
            desc     : ''
            include  : 'diff'
            tags     : []
            examples : []
        }
    
    # Wrapper to ensure @set('tags') is called, as tags.push()
    # will not trigger the 'changed:tags' event.
    addTag: (tag) ->
        return this unless tag
        tags = @get('tags', [])
        tags.push tag
        @set 'tags', tags
        this
    
    # Wrapper to ensure @set('tags') is called, as tags.push()
    # will not trigger the 'changed:tags' event.
    removeTag: (tag) ->
        return this unless tag
        tags = @get('tags', [])
        _.remove tags, tag
        @set 'tags', tags
        this
    
    # Keep tag list up to date
    onTagUpdate: ->
        KNOWN_TAGS.update @get 'tags'
        this
    
    getTagIndex: (tag) ->
        KNOWN_TAGS.get tag
    
    # A field's category is its first tag.
    getCategory: ->
        @get('tags', [])[0]
    
    getCategoryIndex: ->
        @getTagIndex @getCategory()
    
    
    
    getParser: (type) ->
        type or= @get 'type'
        t = _ type.toLowerCase()
        
        parser = op.toStr
        if t.startsWith 'integer'
            parser = op.toInt
        if t.startsWith 'float'
            parser = op.toFloat
        if t.startsWith 'boolean'
            parser = op.toBool
        if t.startsWith 'object' or t.startsWith 'array'
            parser = op.toObject
        if t.startsWith 'function'
            parser = (fn) -> eval "(#fn)"
        
        # TODO: handle 'or' by returning an array of parsers
        parser
    
        
    getValue: (def) ->
        @getParser() @get 'value', def
    
    setValue: (v, options) ->
        def = @get 'default'
        if not v and def == null
            val = null
        else
            val = @getParser()(v)
        @set 'value', val, options
    
    clearValue: ->
        @set 'value', @get('default')
    
    isDefault: ->
        @get('value') is @get('default')
    
    
    toJSON: ->
        {id:@id} import do
            _.clone(@attributes) import { value:@getValue(), def:@get('default') }
    
    toString: -> "(#{@id}: #{@get 'value'})"
# }}}


FieldList = exports.FieldList = Backbone.Collection.extend do # {{{
    ctorName : 'FieldList'
    model : Field
    
    /**
     * Collects a map of fields to their values, excluding those set to `null` or their default.
     * @returns {Object}
     */
    values: ->
        _.synthesize do
            @models.filter -> not it.isDefault()
            -> [ it.get('name'), it.getValue() ]
    
    toString: -> "#{@ctorName}(length=#{@length})"
# }}}

