#!/usr/bin/env coco


fs      = {existsSync:exists}   = require 'fs'
path    = {dirname}             = require 'path'
subproc = {exec, spawn}         = require 'child_process'

glob    = require 'glob'
yaml    = require 'js-yaml'
Seq     = require 'seq'
express = require 'express'

{_, op}                         = require '../util'
{mkdirp, mkdirpAsync}           = require './mkdirp'
{readFilesAsync}                = require './files'
Controller                      = require './controller'



/**
 * Limn project-internals
 */
BASE   = dirname dirname __dirname
WWW    = "#BASE/www"
VAR    = "#BASE/var"
STATIC = "#BASE/static"
DIST   = "#BASE/dist"
DATA   = "#BASE/data"

NODE_ENV = process.env.NODE_ENV or 'development'
IS_DEV   = NODE_ENV is 'development'
IS_PROD  = NODE_ENV is 'production'

LOG_LEVEL = process.env.KRAKEN_LOG_LEVEL
LOG_LEVEL or= if IS_DEV then 'INFO' else 'WARN'
LOG_LEVEL .= toUpperCase()

REV = process.env.KRAKEN_REV or 'HEAD'
try REV = require '../version' catch e



DEFAULT_OPTIONS =
    dataDir         : './data' # Path to directory where data files should be written.
    # datasetDir      : null     # Path to a directory to statically serve as `/data` if present.
    proxy :
        enabled     : false    # Enables remote dataset proxy. If omitted, the proxy will be enabled if either `proxy.whitelist` or `proxy.blacklist` are set.
        whitelist   : null     # Array of domain patterns to whitelist for proxy. Strings are matched via glob-like syntax, but regular expressions may also be passed. If `proxy.enabled` is true but no whitelist is provided, it defaults to `['*']`.
        blacklist   : null     # Array of domain patterns to blacklist from proxying. Strings are matched via glob-like syntax, but regular expressions may also be passed.




# expose API
exports = module.exports = limn


/**
 * Create a new instance of the Limn middleware.
 * @param {Object} [options={}] Options:
 */
function limn(options)
    app = express.createServer()
    app = _.extend app, application
    app.init()
    app



application = limn.application = 
    
    /**
     * @constructor
     */
    init : (opts={}) ->
        @REV  = REV
        @BASE = BASE
        
        ### setup options with defaults
        opts = _.merge {}, DEFAULT_OPTIONS, opts
        opx = opts.proxy
        opx.enabled = true if opx.enabled is false and (opx.whitelist or opx.blacklist)
        if opx.enabled
            opx.whitelist or= [ /.*/ ]
            opx.blacklist or= []
        @set 'limn options', opts
        
        
        ### apply configuration
        
        # config shared by all environments
        @configure ->
            @set 'views', WWW
            @set 'view engine', 'jade'
            @set 'view options', {
                layout  : false
                version : REV
                IS_DEV, IS_PROD
            } import require './view-helpers'
            
            # @helpers require './view-helpers'
            
            # Parse URL, fiddle
            @use require('./reqinfo')({})
            
            # Parse form submits into req.params
            @use express.bodyParser()
            
            # Allow "spoofing" HTTP methods that IE doesn't support
            @use express.methodOverride()
            
            # Route to the web services
            @use @router
            
            # Browserify some deps
            @use require('browserify') do
                mount   : '/vendor/browserify.js'
                require : <[ seq d3 events ]>
                cache   : "#BASE/.cache/browserify/cache.json"
        
        # production config
        @configure 'production', ->
            # log all requests
            @use express.logger()
            
            # set a one year max-age for static files
            @set 'static max age', 31_557_600_000_ms
            
            # show simple errors
            @use express.errorHandler()
        
        
        # development config
        @configure 'development', ->
            # show exceptions, pretty stack traces
            @use express.errorHandler { +dumpExceptions, +showStack }
            
            # turn on pretty-printing of views
            @set('view options').pretty = true
            
            # import dev-only deps here, so prod users don't need them
            compiler = require 'connect-compiler-extras'
            
            # transparently recompile modules that have changed
            @use compiler do
                enabled : <[ coco jade-browser stylus yaml ]>
                src     : WWW
                dest    : VAR
                options : stylus : { nib:true, include:"#WWW/css" }
                log_level : LOG_LEVEL
            @use compiler do
                enabled : 'yaml'
                src     : DATA
                dest    : "#VAR/data"
                log_level : LOG_LEVEL
            
            # wrap modules in commonjs closure for browser
            @use compiler do
                enabled : 'commonjs_define'
                src     : [ STATIC ]
                dest    : VAR
                options :
                    commonjs        : { drop_path_parts:1, drop_full_ext:false }
                    commonjs_define : { drop_path_parts:1, drop_full_ext:false }
                log_level : LOG_LEVEL
            @use compiler do
                enabled : 'commonjs_define'
                src     : [ VAR, WWW ]
                dest    : VAR
                options :
                    commonjs        : { drop_path_parts:1, drop_full_ext:true }
                    commonjs_define : { drop_path_parts:1, drop_full_ext:true }
                log_level : LOG_LEVEL
        
        # serve static files
        @configure ->
            opts = @set('static file options') or {}
            @use express.static DIST, ^opts if exists DIST
            @use express.static WWW, ^opts
            @use express.static VAR, ^opts
            @use express.static STATIC, ^opts
        
        
        
        # data controllers
        @controller require './controllers/graph'
        @controller require './controllers/dashboard'
        
        YAML_EXT_PAT = /\.ya?ml$/i
        @get '/datasources/all', (req, res, next) ->
            data = {}
            Seq()
                .seq glob, 'data/datasources/**/*.@(yaml|json)', {+nocase, +nosort}, Seq
                .seq (paths) -> readFilesAsync paths, this
                .seq (txts) -> @ok _.items txts
                .flatten false
                .parMap ([f, text]) ->
                    # console.log "parsing file[#i]: '#f' -> text[#{text.length}]..."
                    k = f.replace YAML_EXT_PAT, '.json'
                    v = data[k] = {}
                    try
                        if YAML_EXT_PAT.test f
                            v = data[k] = yaml.load text
                        else
                            v = data[k] = JSON.parse text
                        # console.log "#f ok!", data
                        @ok v
                    catch err
                        console.error "[/data/all] catch! #err"
                        console.error err
                        console.error that if err.stack
                        res.send { error:String(err), partial_data:data }
                .seq -> res.send data
                .catch (err) ->
                    console.error '[/data/all] catch!'
                    console.error err
                    console.error that if err.stack
                    res.send { error:String(err), partial_data:data }
        
        @controller require './controllers/datasource'
        
        
        # proxy endpoint
        if opts.proxy.enabled
            proxy = require('./proxy')({
                blacklist: opts.proxy.blacklist
                whitelist: opts.proxy.whitelist
            })
            @get '/x',   proxy
            @get '/x/*', proxy
        
        
        # non-controller endpoints
        @get '/', (req, res) ->
            res.render 'dashboard'
        
        @get '/geo', (req, res) ->
            res.render 'geo'
        
        @get '/:type/:action/?', (req, res, next) ->
            {type, action} = req.params
            if exists "#WWW/#type/#action.jade"
                res.render "#type/#action"
            else
                next()
        
        @get '/:type/?', (req, res, next) ->
            {type} = req.params
            if exists "#WWW/#type.jade"
                res.render "#type"
            else
                next()
        
        this
    


