#!/usr/bin/env coco

fs       = require 'fs'
path     = require 'path'
{parse}  = require 'url'
{existsSync:exists} = path
{exec, spawn} = require 'child_process'

_        = require 'underscore'
_.str    = require 'underscore.string'
_.mixin _.str.exports()

Seq      = require 'seq'
yaml     = require 'js-yaml'
mime     = require 'mime'
express  = require 'express'
compiler = require 'connect-compiler-extras'



### Config

PORT = 8081

CWD    = process.cwd()
WWW    = "#CWD/www"
VAR    = "#CWD/var"
STATIC = "#CWD/static"

NODE_ENV  = process.env.NODE_ENV or 'development'
LOG_LEVEL = if NODE_ENV is 'development' then 'INFO' else 'WARN'


VERSION = 'dev'
err, stdout, stderr <- exec 'git rev-parse --short HEAD', {cwd:CWD, env:process.env}
throw err if err
VERSION = stdout.trim!

# err <- fs.writeFile 'lib/version.js', "module.exports = exports = '#{VERSION}';\n", 'utf8'
# try VERSION = require '../version' catch e


### Setup

app = express.createServer()

app.start = ->
    console.log "starting Kraken dev server (port=#PORT, env=#NODE_ENV, version=#VERSION)"
    console.log "========================================================================"
    app.listen PORT
    app

app.configure ->
    mime.define 'text/plain' : <[ jade co styl stylus ]>
    
    # Set up 
    app.set 'views', WWW
    app.set 'view engine', 'jade'
    app.set 'view options', {
        layout  : false
        pretty  : true
        version : VERSION
    } import require './view-helpers'
    
    app.use express.logger() if LOG_LEVEL is 'DEBUG'
    
    # Parse URL, fiddle
    app.use require('./reqinfo')({})
    
    # Parse form submits into req.params
    app.use express.bodyParser()
    
    # Allow "spoofing" HTTP methods that IE doesn't support
    app.use express.methodOverride()
    
    # Route to the web services
    app.use app.router
    
    # Transparently recompile modules that have changed
    app.use compiler do
        enabled : <[ coco jade-browser stylus yaml ]>
        src     : WWW
        dest    : VAR
        options : stylus : { nib:true, include:"#WWW/css" }
        log_level : LOG_LEVEL
    
    # wrap modules in commonjs closure for browser
    app.use compiler do
        enabled : 'commonjs'
        src     : [ STATIC ]
        dest    : VAR
        options : commonjs : { drop_path_parts:1, drop_full_ext:false }
        log_level : LOG_LEVEL
    app.use compiler do
        enabled : 'commonjs'
        src     : [ VAR, WWW ]
        dest    : VAR
        options : commonjs : { drop_path_parts:1, drop_full_ext:true }
        log_level : LOG_LEVEL
    app.use require('browserify') do
        mount   : '/vendor/browserify.js'
        require : <[ events seq hashish ]>
    
    # Serve static files
    app.use express.static WWW
    app.use express.static VAR
    app.use express.static STATIC
    
    # Serve directory listings
    # app.use express.directory WWW
    # app.use express.directory VAR
    # app.use express.directory STATIC
    
    app.use express.errorHandler do
        dumpExceptions : true
        showStack      : true


/* * * *  Routes  * * * {{{ */

app.get '/', (req, res) ->
    res.render 'dashboard'

app.post '/graph/save', (req, res, next) ->
    if not req.body
        return res.send {result:"error", message:"JSON required!"}, 501
    
    data = req.body
    {slug} = data
    if not slug
        return res.send {result:"error", message:"slug required!"}, 501
    
    err <- fs.writeFile "#WWW/presets/#slug.json", JSON.stringify(data), "utf8"
    if err
        res.send { result:"error", message:err.message or String(err) }, 501
    else
        res.send {result:"ok"}


app.get '/graph/:slug\.json', (req, res, next) ->
    req.url .= replace /^\/graph\//i, '/presets/'
    next()

app.get '/preset/:slug', (req, res, next) ->
    {slug} = req.params
    if exists("#WWW/presets/#slug.yaml") or exists("#WWW/presets/#slug.json")
        req.url .= replace /^\/preset\/[^\/?]/i, "/presets/#slug.json"
        # req.url += '.json'
    next()

app.get '/graph(/:slug)?/?', (req, res, next) ->
    {slug} = req.params
    # console.log '/graph/:slug/?'
    # console.log '  slug:  ', slug
    # console.log '  params:', req.params
    unless _.str.include slug, '.'
        {pathname, search or ''} = req.info
        req.url = "#pathname/view#search"
        req.params.action = 'view'
    next()

app.get '/graph/:slug/:action/?', (req, res) ->
    {slug, action} = req.params
    res.render "graph/#action"

app.get '/:type/:action/?', (req, res, next) ->
    {type, action} = req.params
    if path.existsSync "#WWW/#type/#action.jade"
        res.render "#type/#action"
    else
        next()



# }}}
/* * * *  Data Source Oracle  * * * {{{ */

YAML_EXT_PAT = /\.ya?ml$/i

/**
 * Returns a JSON listing of the datasource metadata files.
 */
app.get '/data/list', (req, res, next) ->
    fs.readdir "#CWD/data", (err, files) ->
        res.send do
            files.filter -> /\.(json|ya?ml)$/i.test it
                 .map    -> "/data/#it".replace YAML_EXT_PAT, '.json'

/**
 * Returns the aggregated JSON content of the datasource metadata files.
 */
app.get '/data/all', (req, res, next) ->
    data = {}
    files = []
    Seq()
        .seq fs.readdir, "#CWD/data", Seq
        .flatten()
        .filter -> /\.(json|ya?ml)$/.test it
        .seq ->
            files := @stack.slice()
            # console.log 'files:', files
            @ok files
        .flatten()
        .parMap (f) ->
            # console.log "fs.readFile '#CWD/data/#f'"
            fs.readFile "#CWD/data/#f", 'utf8', this
        .parMap (text, i) ->
            f = files[i]
            # console.log "parsing file[#i]: '#f' -> text[#{text.length}]..."
            k = f.replace YAML_EXT_PAT, '.json'
            v = data[k] = {}
            try
                if YAML_EXT_PAT.test f
                    v = data[k] = yaml.load text
                else
                    v = data[k] = JSON.parse text
                # console.log "#f ok!", data
                @ok v
            catch err
                console.error "[/data/all] catch! #err"
                console.error err
                console.error that if err.stack
                res.send { error:String(err), partial_data:data }
        .seq -> res.send data
        .catch (err) ->
            console.error '[/data/all] catch!'
            console.error err
            console.error that if err.stack
            res.send { error:String(err), partial_data:data }

# }}}

/**
 * Handle webhook notification to pull from origin.
 */
app.all '/webhook/post-update', (req, res) ->
    
    # exec the pull async...
    console.log '[/webhook/post-update] $ git pull origin master'
    child = exec 'git pull origin master', (err, stdout, stderr) ->
        res.contentType '.txt'
        console.log '[/webhook/post-update]  ', stdout
        console.log '[/webhook/post-update]  ', stderr
        if err
            console.error '[/webhook/post-update] ERROR!', err
            res.send "#stdout\n\n#stderr\n\nERROR! #err", 503
        else
            res.send "#stdout\n\n#stderr", 200




exports import {
    CWD, WWW, VAR, STATIC,
    PORT, LOG_LEVEL, NODE_ENV, VERSION,
    app, module, require,
}

mainfile = path.basename require.main?.filename
if require.main is module or 'Cokefile' is mainfile
    app.start()

