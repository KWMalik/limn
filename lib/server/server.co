#!/usr/bin/env coco

fs     = require 'fs'
path   = require 'path'
findit = require 'findit'
{existsSync:exists} = path
{exec, spawn} = require 'child_process'
{mkdirp, mkdirpAsync} = require './mkdirp'

_        = require 'underscore'
_.str    = require 'underscore.string'
_.mixin _.str.exports()

Seq      = require 'seq'
yaml     = require 'js-yaml'
mime     = require 'mime'
express  = require 'express'
Resource = require 'express-resource'
compiler = require 'connect-compiler-extras'


### Config

# TODO: read KRAKEN_PORT from ENV
PORT = 8081

CWD    = process.cwd()
WWW    = "#CWD/www"
VAR    = "#CWD/var"
STATIC = "#CWD/static"
DIST   = "#CWD/dist"
DATA   = "#CWD/data"

NODE_ENV  = process.env.NODE_ENV or 'dev'
LOG_LEVEL = if _.startsWith NODE_ENV, 'dev' then 'INFO' else 'WARN'
# LOG_LEVEL = 'DEBUG'


VERSION = 'dev'
err, stdout, stderr <- exec 'git rev-parse --short HEAD', {cwd:CWD, env:process.env}
throw err if err
VERSION = stdout.trim!

# err <- fs.writeFile 'lib/version.js', "module.exports = exports = '#{VERSION}';\n", 'utf8'
# try VERSION = require '../version' catch e


### Setup

app = express.createServer()

app.start = ->
    console.log "starting Kraken dev server (port=#PORT, env=#NODE_ENV, version=#VERSION)"
    console.log "========================================================================"
    app.listen PORT
    app

app.configure ->
    mime.define 'text/plain' : <[ jade co styl stylus ]>
    
    # Set up 
    app.set 'views', WWW
    app.set 'view engine', 'jade'
    app.set 'view options', {
        layout  : false
        pretty  : true
        version : VERSION
    } import require './view-helpers'
    
    app.use express.logger()   if LOG_LEVEL is 'DEBUG'
    # app.use express.logger()
    
    # Parse URL, fiddle
    app.use require('./reqinfo')({})
    
    # Parse form submits into req.params
    app.use express.bodyParser()
    
    # Allow "spoofing" HTTP methods that IE doesn't support
    app.use express.methodOverride()
    
    # Route to the web services
    app.use app.router
    
    # Transparently recompile modules that have changed
    app.use compiler do
        enabled : <[ coco jade-browser stylus yaml ]>
        src     : WWW
        dest    : VAR
        options : stylus : { nib:true, include:"#WWW/css" }
        log_level : LOG_LEVEL
    
    app.use compiler do
        enabled : 'yaml'
        src     : DATA
        dest    : "#VAR/data"
        log_level : LOG_LEVEL
    
    # wrap modules in commonjs closure for browser
    app.use compiler do
        enabled : 'commonjs_define'
        src     : [ STATIC ]
        dest    : VAR
        options :
            commonjs        : { drop_path_parts:1, drop_full_ext:false }
            commonjs_define : { drop_path_parts:1, drop_full_ext:false }
        log_level : LOG_LEVEL
    app.use compiler do
        enabled : 'commonjs_define'
        src     : [ VAR, WWW ]
        dest    : VAR
        options :
            commonjs        : { drop_path_parts:1, drop_full_ext:true }
            commonjs_define : { drop_path_parts:1, drop_full_ext:true }
        log_level : LOG_LEVEL
    app.use require('browserify') do
        mount   : '/vendor/browserify.js'
        require : <[ events seq ]>
    
    # Serve static files
    app.use express.static WWW
    app.use express.static VAR
    app.use express.static STATIC
    # app.use express.static DIST if exists DIST
    app.use express.static DIST if NODE_ENV is 'prod'
    
    # Serve directory listings
    # app.use express.directory WWW
    # app.use express.directory VAR
    # app.use express.directory STATIC
    # app.use express.directory DIST
    
    app.use express.errorHandler do
        dumpExceptions : true
        showStack      : true



/* * * *  Routes and Controllers  * * * {{{ */

Controller   = require './controller'
app.controller require './controllers/graph'
ds = app.controller require './controllers/datasource'
# ds.map 'get', 'all', ds.allData.bind(ds)

YAML_EXT_PAT = /\.ya?ml$/i
app.get '/datasources/all', (req, res, next) ->
    data = {}
    files = []
    Seq(findit.sync 'data/datasources')
        # .seq fs.readdir, 'data/datasources', Seq
        # .flatten()
        .filter -> /\.(json|ya?ml)$/.test it
        .seq ->
            files := @stack.slice()
            # console.log 'files:', files
            @ok files
        .flatten()
        .parMap (f) ->
            # console.log "fs.readFile '#CWD/data/#f'"
            fs.readFile f, 'utf8', this
        .parMap (text, i) ->
            f = files[i]
            # console.log "parsing file[#i]: '#f' -> text[#{text.length}]..."
            k = f.replace YAML_EXT_PAT, '.json'
            v = data[k] = {}
            try
                if YAML_EXT_PAT.test f
                    v = data[k] = yaml.load text
                else
                    v = data[k] = JSON.parse text
                # console.log "#f ok!", data
                @ok v
            catch err
                console.error "[/data/all] catch! #err"
                console.error err
                console.error that if err.stack
                res.send { error:String(err), partial_data:data }
        .seq -> res.send data
        .catch (err) ->
            console.error '[/data/all] catch!'
            console.error err
            console.error that if err.stack
            res.send { error:String(err), partial_data:data }


app.get '/', (req, res) ->
    res.render 'dashboard'

app.get '/:type/:action/?', (req, res, next) ->
    {type, action} = req.params
    if exists "#WWW/#type/#action.jade"
        res.render "#type/#action"
    else
        next()

/**
 * Handle webhook notification to pull from origin.
 */
app.all '/webhook/post-update', (req, res) ->

    # exec the pull async...
    cmd = 'git pull origin master'
    console.log "[/webhook/post-update] $ #cmd"
    child = exec cmd, (err, stdout, stderr) ->
        res.contentType '.txt'
        console.log '[/webhook/post-update]  ', stdout
        console.log '[/webhook/post-update]  ', stderr
        if err
            console.error '[/webhook/post-update] ERROR!', err
            res.send "$ #cmd\n\n#stdout\n\n#stderr\n\nERROR! #err", 503
        else
            res.send "$ #cmd\n\n#stdout\n\n#stderr", 200


# }}}

exports import {
    CWD, WWW, VAR, STATIC,
    PORT, LOG_LEVEL, NODE_ENV, VERSION,
    app, module, require,
}

mainfile = path.basename require.main?.filename
if require.main is module or 'Cokefile' is mainfile
    app.start()

