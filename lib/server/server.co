#!/usr/bin/env coco

fs     = require 'fs'
path   = require 'path'
glob   = require 'glob'
{existsSync:exists} = path
{exec, spawn} = require 'child_process'
{mkdirp, mkdirpAsync} = require './mkdirp'
{ readFilesAsync, readJSONFilesAsync,
} = require './files'


Seq      = require 'seq'
yaml     = require 'js-yaml'
mime     = require 'mime'
express  = require 'express'
Resource = require 'express-resource'
compiler = require 'connect-compiler-extras'

_        = require '../util/underscore'
op       = require '../util/op'
files    = require './files'



### Config

CWD    = process.cwd()
WWW    = "#CWD/www"
VAR    = "#CWD/var"
STATIC = "#CWD/static"
DIST   = "#CWD/dist"
DATA   = "#CWD/data"

PORT = 8081
PORT = parseInt(that, 10) if process.env.KRAKEN_PORT

NODE_ENV  = process.env.NODE_ENV or 'dev'

LOG_LEVEL = process.env.KRAKEN_LOG_LEVEL
LOG_LEVEL or= if _.startsWith NODE_ENV, 'dev' then 'INFO' else 'WARN'
LOG_LEVEL .= toUpperCase()

USE_LOGGER = op.parseBool(process.env.KRAKEN_USE_LOGGER) or LOG_LEVEL is 'DEBUG' or NODE_ENV is 'prod'

VERSION = process.env.KRAKEN_VERSION or 'dev'
err, stdout, stderr <- exec 'git rev-parse --short HEAD', {cwd:CWD, env:process.env}
throw err if err
VERSION = stdout.trim!


### Setup

app = express.createServer()

app.start = ->
    console.log s = "Kraken Server (port=#PORT, env=#NODE_ENV, version=#VERSION)"
    console.log '=' * s.length
    app.listen PORT
    app

app.configure ->
    mime.define 'text/plain' : <[ jade co styl stylus ]>
    
    # Set up 
    app.set 'views', WWW
    app.set 'view engine', 'jade'
    app.set 'view options', {
        layout  : false
        pretty  : true
        version : VERSION
    } import require './view-helpers'
    
    app.use express.logger() if USE_LOGGER
    
    # Parse URL, fiddle
    app.use require('./reqinfo')({})
    
    # Parse form submits into req.params
    app.use express.bodyParser()
    
    # Allow "spoofing" HTTP methods that IE doesn't support
    app.use express.methodOverride()
    
    # Route to the web services
    app.use app.router
    
    # Transparently recompile modules that have changed
    app.use compiler do
        enabled : <[ coco jade-browser stylus yaml ]>
        src     : WWW
        dest    : VAR
        options : stylus : { nib:true, include:"#WWW/css" }
        log_level : LOG_LEVEL
    
    app.use compiler do
        enabled : 'yaml'
        src     : DATA
        dest    : "#VAR/data"
        log_level : LOG_LEVEL
    
    # wrap modules in commonjs closure for browser
    app.use compiler do
        enabled : 'commonjs_define'
        src     : [ STATIC ]
        dest    : VAR
        options :
            commonjs        : { drop_path_parts:1, drop_full_ext:false }
            commonjs_define : { drop_path_parts:1, drop_full_ext:false }
        log_level : LOG_LEVEL
    app.use compiler do
        enabled : 'commonjs_define'
        src     : [ VAR, WWW ]
        dest    : VAR
        options :
            commonjs        : { drop_path_parts:1, drop_full_ext:true }
            commonjs_define : { drop_path_parts:1, drop_full_ext:true }
        log_level : LOG_LEVEL
    app.use require('browserify') do
        mount   : '/vendor/browserify.js'
        require : <[ events seq ]>
        cache   : "#CWD/.cache/browserify/cache.json"
    
    # Serve static files
    app.use express.static WWW
    app.use express.static VAR
    app.use express.static STATIC
    # app.use express.static DIST if exists DIST
    app.use express.static DIST if NODE_ENV is 'prod'
    
    # Serve directory listings
    # app.use express.directory WWW
    # app.use express.directory VAR
    # app.use express.directory STATIC
    # app.use express.directory DIST
    
    app.use express.errorHandler do
        dumpExceptions : true
        showStack      : true



/* * * *  Routes and Controllers  * * * {{{ */

Controller   = require './controller'
app.controller require './controllers/graph'
app.controller require './controllers/datasource'

YAML_EXT_PAT = /\.ya?ml$/i
app.get '/datasources/all', (req, res, next) ->
    data = {}
    Seq
        .seq glob, 'data/datasources/**/*.@(yaml|json)', {+nocase, +nosort}, Seq
        .seq (paths) -> readFilesAsync paths, this
        .seq (txts) -> @ok _.items txts
        .flatten false
        .parMap ([f, text]) ->
            # console.log "parsing file[#i]: '#f' -> text[#{text.length}]..."
            k = f.replace YAML_EXT_PAT, '.json'
            v = data[k] = {}
            try
                if YAML_EXT_PAT.test f
                    v = data[k] = yaml.load text
                else
                    v = data[k] = JSON.parse text
                # console.log "#f ok!", data
                @ok v
            catch err
                console.error "[/data/all] catch! #err"
                console.error err
                console.error that if err.stack
                res.send { error:String(err), partial_data:data }
        .seq -> res.send data
        .catch (err) ->
            console.error '[/data/all] catch!'
            console.error err
            console.error that if err.stack
            res.send { error:String(err), partial_data:data }

# FIXME:  Make /graphs.json do this instead of graphslist.
#      :  Can I use Seq .par to read in data and also parse the JSON?
# Sends a JSON list of saved graphs.  These
# can be used to instantiate a GraphList of Graph Models.
app.get '/graphslist' (req, res) ->
    Seq()
        # find list of data/graph/*.json files, send back the objects
        .seq            -> readJSONFilesAsync "#DATA/graphs/*.json", this
        # remove filepath info
        .seq   (graphs) -> res.send _.values graphs

app.get '/', (req, res) ->
    res.render 'dashboard'

app.get '/:type/:action/?', (req, res, next) ->
    {type, action} = req.params
    if exists "#WWW/#type/#action.jade"
        res.render "#type/#action"
    else
        next()

/**
 * Handle webhook notification to pull from origin.
 */
app.all '/webhook/post-update', (req, res) ->

    # exec the pull async...
    cmd = 'git pull origin master'
    console.log "[/webhook/post-update] $ #cmd"
    child = exec cmd, (err, stdout, stderr) ->
        res.contentType '.txt'
        console.log '[/webhook/post-update]  ', stdout
        console.log '[/webhook/post-update]  ', stderr
        if err
            console.error '[/webhook/post-update] ERROR!', err
            res.send "$ #cmd\n\n#stdout\n\n#stderr\n\nERROR! #err", 503
        else
            res.send "$ #cmd\n\n#stdout\n\n#stderr", 200


# }}}

exports import {
    CWD, WWW, VAR, STATIC,
    PORT, LOG_LEVEL, NODE_ENV, VERSION,
    app, module, require,
}

mainfile = path.basename require.main?.filename
if require.main is module or 'Cokefile' is mainfile
    app.start()

